// Code generated from SqlBase.g4 by ANTLR 4.9. DO NOT EDIT.

package parser // SqlBase
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 239, 1098,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	5, 2, 100, 10, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 106, 10, 2, 5, 2, 108,
	10, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 114, 10, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	5, 2, 120, 10, 2, 5, 2, 122, 10, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	5, 2, 130, 10, 2, 5, 2, 132, 10, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 138,
	10, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 144, 10, 2, 5, 2, 146, 10, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 169, 10, 2, 5, 2,
	171, 10, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 179, 10, 2, 5, 2,
	181, 10, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2,
	192, 10, 2, 3, 3, 5, 3, 195, 10, 3, 3, 3, 3, 3, 3, 4, 3, 4, 5, 4, 201,
	10, 4, 3, 4, 3, 4, 3, 4, 7, 4, 206, 10, 4, 12, 4, 14, 4, 209, 11, 4, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 217, 10, 5, 12, 5, 14, 5, 220, 11,
	5, 5, 5, 222, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 227, 10, 5, 5, 5, 229, 10,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 236, 10, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 5, 5, 242, 10, 5, 5, 5, 244, 10, 5, 3, 6, 3, 6, 5, 6, 248, 10, 6, 3,
	7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 258, 10, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 5, 8, 264, 10, 8, 3, 8, 7, 8, 267, 10, 8, 12, 8, 14, 8,
	270, 11, 8, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 7, 9, 279, 10, 9,
	12, 9, 14, 9, 282, 11, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 288, 10, 9, 3,
	10, 3, 10, 5, 10, 292, 10, 10, 3, 10, 3, 10, 5, 10, 296, 10, 10, 3, 11,
	3, 11, 5, 11, 300, 10, 11, 3, 11, 3, 11, 3, 11, 7, 11, 305, 10, 11, 12,
	11, 14, 11, 308, 11, 11, 3, 11, 3, 11, 3, 11, 3, 11, 7, 11, 314, 10, 11,
	12, 11, 14, 11, 317, 11, 11, 5, 11, 319, 10, 11, 3, 11, 3, 11, 5, 11, 323,
	10, 11, 3, 11, 3, 11, 3, 11, 5, 11, 328, 10, 11, 3, 11, 3, 11, 5, 11, 332,
	10, 11, 3, 12, 5, 12, 335, 10, 12, 3, 12, 3, 12, 3, 12, 7, 12, 340, 10,
	12, 12, 12, 14, 12, 343, 11, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3,
	13, 7, 13, 351, 10, 13, 12, 13, 14, 13, 354, 11, 13, 5, 13, 356, 10, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 7, 13, 364, 10, 13, 12, 13, 14,
	13, 367, 11, 13, 5, 13, 369, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 7, 13, 378, 10, 13, 12, 13, 14, 13, 381, 11, 13, 3, 13, 3,
	13, 5, 13, 385, 10, 13, 3, 14, 3, 14, 3, 14, 3, 14, 7, 14, 391, 10, 14,
	12, 14, 14, 14, 394, 11, 14, 5, 14, 396, 10, 14, 3, 14, 3, 14, 5, 14, 400,
	10, 14, 3, 15, 3, 15, 5, 15, 404, 10, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3,
	15, 3, 16, 3, 16, 3, 17, 3, 17, 5, 17, 415, 10, 17, 3, 17, 5, 17, 418,
	10, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 5, 17, 425, 10, 17, 3, 17, 5,
	17, 428, 10, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 447,
	10, 18, 7, 18, 449, 10, 18, 12, 18, 14, 18, 452, 11, 18, 3, 19, 5, 19,
	455, 10, 19, 3, 19, 3, 19, 5, 19, 459, 10, 19, 3, 19, 3, 19, 5, 19, 463,
	10, 19, 3, 19, 3, 19, 5, 19, 467, 10, 19, 5, 19, 469, 10, 19, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 7, 20, 478, 10, 20, 12, 20, 14,
	20, 481, 11, 20, 3, 20, 3, 20, 5, 20, 485, 10, 20, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 494, 10, 21, 3, 22, 3, 22, 3, 23, 3,
	23, 5, 23, 500, 10, 23, 3, 23, 3, 23, 5, 23, 504, 10, 23, 5, 23, 506, 10,
	23, 3, 24, 3, 24, 3, 24, 3, 24, 7, 24, 512, 10, 24, 12, 24, 14, 24, 515,
	11, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	3, 25, 3, 25, 3, 25, 7, 25, 529, 10, 25, 12, 25, 14, 25, 532, 11, 25, 3,
	25, 3, 25, 3, 25, 5, 25, 537, 10, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 548, 10, 25, 3, 26, 3, 26, 3, 27, 3,
	27, 3, 27, 5, 27, 555, 10, 27, 3, 27, 3, 27, 5, 27, 559, 10, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 7, 27, 567, 10, 27, 12, 27, 14, 27,
	570, 11, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 28, 5, 28, 582, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	5, 28, 590, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 597, 10,
	28, 12, 28, 14, 28, 600, 11, 28, 3, 28, 3, 28, 3, 28, 5, 28, 605, 10, 28,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 613, 10, 28, 3, 28, 3,
	28, 3, 28, 3, 28, 5, 28, 619, 10, 28, 3, 28, 3, 28, 5, 28, 623, 10, 28,
	3, 28, 3, 28, 3, 28, 5, 28, 628, 10, 28, 3, 28, 3, 28, 3, 28, 5, 28, 633,
	10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 639, 10, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29,
	653, 10, 29, 12, 29, 14, 29, 656, 11, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 6,
	30, 683, 10, 30, 13, 30, 14, 30, 684, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 7, 30, 694, 10, 30, 12, 30, 14, 30, 697, 11, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 706, 10, 30, 3, 30, 3, 30,
	3, 30, 5, 30, 711, 10, 30, 3, 30, 3, 30, 3, 30, 7, 30, 716, 10, 30, 12,
	30, 14, 30, 719, 11, 30, 5, 30, 721, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 7, 30, 728, 10, 30, 12, 30, 14, 30, 731, 11, 30, 5, 30, 733, 10,
	30, 3, 30, 3, 30, 5, 30, 737, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 7, 30, 747, 10, 30, 12, 30, 14, 30, 750, 11, 30, 5,
	30, 752, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 6, 30, 769, 10, 30, 13,
	30, 14, 30, 770, 3, 30, 3, 30, 5, 30, 775, 10, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 6, 30, 781, 10, 30, 13, 30, 14, 30, 782, 3, 30, 3, 30, 5, 30, 787,
	10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 7, 30, 810, 10, 30, 12, 30, 14, 30, 813, 11, 30, 5, 30, 815,
	10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 824, 10,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 830, 10, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 5, 30, 836, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 842, 10,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30,
	853, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 862,
	10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 882,
	10, 30, 12, 30, 14, 30, 885, 11, 30, 5, 30, 887, 10, 30, 3, 30, 5, 30,
	890, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7,
	30, 900, 10, 30, 12, 30, 14, 30, 903, 11, 30, 3, 31, 3, 31, 3, 31, 3, 31,
	5, 31, 909, 10, 31, 5, 31, 911, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3,
	32, 3, 32, 5, 32, 919, 10, 32, 3, 33, 3, 33, 3, 34, 3, 34, 3, 35, 3, 35,
	3, 36, 3, 36, 5, 36, 929, 10, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 935,
	10, 36, 3, 37, 3, 37, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 7, 39, 947, 10, 39, 12, 39, 14, 39, 950, 11, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 5, 39, 958, 10, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 5, 39, 965, 10, 39, 3, 39, 3, 39, 3, 39, 5, 39, 970, 10, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 977, 10, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 987, 10, 39, 3, 39, 3, 39, 3,
	39, 5, 39, 992, 10, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 999,
	10, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 7, 39, 1023, 10, 39, 12, 39, 14, 39, 1026, 11, 39, 3,
	39, 3, 39, 5, 39, 1030, 10, 39, 5, 39, 1032, 10, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 5, 39, 1039, 10, 39, 7, 39, 1041, 10, 39, 12, 39, 14, 39,
	1044, 11, 39, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 1050, 10, 40, 3, 41, 3,
	41, 5, 41, 1054, 10, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 7, 44, 1070, 10, 44, 12,
	44, 14, 44, 1073, 11, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 1080,
	10, 45, 3, 46, 5, 46, 1083, 10, 46, 3, 46, 3, 46, 5, 46, 1087, 10, 46,
	3, 46, 3, 46, 5, 46, 1091, 10, 46, 3, 46, 5, 46, 1094, 10, 46, 3, 47, 3,
	47, 3, 47, 2, 8, 14, 34, 52, 56, 58, 76, 48, 2, 4, 6, 8, 10, 12, 14, 16,
	18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
	54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
	90, 92, 2, 19, 4, 2, 74, 74, 88, 88, 3, 2, 163, 164, 4, 2, 70, 70, 116,
	116, 4, 2, 228, 228, 238, 238, 4, 2, 61, 61, 196, 196, 4, 2, 19, 19, 52,
	52, 4, 2, 70, 70, 102, 102, 4, 2, 12, 12, 54, 54, 4, 2, 22, 22, 179, 179,
	3, 2, 219, 220, 3, 2, 221, 223, 3, 2, 213, 218, 5, 2, 12, 12, 16, 16, 175,
	175, 4, 2, 67, 67, 190, 190, 7, 2, 48, 48, 85, 85, 113, 114, 167, 167,
	211, 211, 3, 2, 117, 120, 47, 2, 10, 12, 14, 14, 16, 17, 19, 22, 25, 26,
	29, 34, 39, 39, 46, 48, 50, 50, 52, 52, 55, 56, 62, 62, 65, 65, 68, 71,
	73, 73, 76, 80, 83, 83, 85, 87, 89, 89, 91, 91, 94, 94, 96, 97, 99, 99,
	101, 103, 105, 105, 107, 107, 110, 114, 116, 122, 126, 128, 130, 131, 134,
	134, 136, 143, 145, 148, 150, 157, 159, 161, 163, 168, 170, 179, 181, 183,
	185, 189, 191, 192, 194, 195, 198, 199, 201, 201, 203, 204, 208, 212, 2,
	1273, 2, 191, 3, 2, 2, 2, 4, 194, 3, 2, 2, 2, 6, 198, 3, 2, 2, 2, 8, 210,
	3, 2, 2, 2, 10, 247, 3, 2, 2, 2, 12, 249, 3, 2, 2, 2, 14, 251, 3, 2, 2,
	2, 16, 287, 3, 2, 2, 2, 18, 289, 3, 2, 2, 2, 20, 297, 3, 2, 2, 2, 22, 334,
	3, 2, 2, 2, 24, 384, 3, 2, 2, 2, 26, 399, 3, 2, 2, 2, 28, 401, 3, 2, 2,
	2, 30, 410, 3, 2, 2, 2, 32, 427, 3, 2, 2, 2, 34, 429, 3, 2, 2, 2, 36, 468,
	3, 2, 2, 2, 38, 484, 3, 2, 2, 2, 40, 486, 3, 2, 2, 2, 42, 495, 3, 2, 2,
	2, 44, 497, 3, 2, 2, 2, 46, 507, 3, 2, 2, 2, 48, 547, 3, 2, 2, 2, 50, 549,
	3, 2, 2, 2, 52, 558, 3, 2, 2, 2, 54, 632, 3, 2, 2, 2, 56, 638, 3, 2, 2,
	2, 58, 889, 3, 2, 2, 2, 60, 910, 3, 2, 2, 2, 62, 918, 3, 2, 2, 2, 64, 920,
	3, 2, 2, 2, 66, 922, 3, 2, 2, 2, 68, 924, 3, 2, 2, 2, 70, 926, 3, 2, 2,
	2, 72, 936, 3, 2, 2, 2, 74, 938, 3, 2, 2, 2, 76, 1031, 3, 2, 2, 2, 78,
	1049, 3, 2, 2, 2, 80, 1053, 3, 2, 2, 2, 82, 1055, 3, 2, 2, 2, 84, 1060,
	3, 2, 2, 2, 86, 1066, 3, 2, 2, 2, 88, 1079, 3, 2, 2, 2, 90, 1093, 3, 2,
	2, 2, 92, 1095, 3, 2, 2, 2, 94, 192, 5, 4, 3, 2, 95, 96, 7, 174, 2, 2,
	96, 99, 7, 181, 2, 2, 97, 98, 9, 2, 2, 2, 98, 100, 5, 86, 44, 2, 99, 97,
	3, 2, 2, 2, 99, 100, 3, 2, 2, 2, 100, 107, 3, 2, 2, 2, 101, 102, 7, 106,
	2, 2, 102, 105, 5, 60, 31, 2, 103, 104, 7, 60, 2, 2, 104, 106, 5, 60, 31,
	2, 105, 103, 3, 2, 2, 2, 105, 106, 3, 2, 2, 2, 106, 108, 3, 2, 2, 2, 107,
	101, 3, 2, 2, 2, 107, 108, 3, 2, 2, 2, 108, 192, 3, 2, 2, 2, 109, 110,
	7, 174, 2, 2, 110, 113, 7, 166, 2, 2, 111, 112, 9, 2, 2, 2, 112, 114, 5,
	88, 45, 2, 113, 111, 3, 2, 2, 2, 113, 114, 3, 2, 2, 2, 114, 121, 3, 2,
	2, 2, 115, 116, 7, 106, 2, 2, 116, 119, 5, 60, 31, 2, 117, 118, 7, 60,
	2, 2, 118, 120, 5, 60, 31, 2, 119, 117, 3, 2, 2, 2, 119, 120, 3, 2, 2,
	2, 120, 122, 3, 2, 2, 2, 121, 115, 3, 2, 2, 2, 121, 122, 3, 2, 2, 2, 122,
	192, 3, 2, 2, 2, 123, 124, 7, 174, 2, 2, 124, 131, 7, 29, 2, 2, 125, 126,
	7, 106, 2, 2, 126, 129, 5, 60, 31, 2, 127, 128, 7, 60, 2, 2, 128, 130,
	5, 60, 31, 2, 129, 127, 3, 2, 2, 2, 129, 130, 3, 2, 2, 2, 130, 132, 3,
	2, 2, 2, 131, 125, 3, 2, 2, 2, 131, 132, 3, 2, 2, 2, 132, 192, 3, 2, 2,
	2, 133, 134, 7, 174, 2, 2, 134, 135, 7, 31, 2, 2, 135, 137, 9, 2, 2, 2,
	136, 138, 5, 86, 44, 2, 137, 136, 3, 2, 2, 2, 137, 138, 3, 2, 2, 2, 138,
	145, 3, 2, 2, 2, 139, 140, 7, 106, 2, 2, 140, 143, 5, 60, 31, 2, 141, 142,
	7, 60, 2, 2, 142, 144, 5, 60, 31, 2, 143, 141, 3, 2, 2, 2, 143, 144, 3,
	2, 2, 2, 144, 146, 3, 2, 2, 2, 145, 139, 3, 2, 2, 2, 145, 146, 3, 2, 2,
	2, 146, 192, 3, 2, 2, 2, 147, 148, 7, 174, 2, 2, 148, 149, 7, 177, 2, 2,
	149, 150, 7, 72, 2, 2, 150, 192, 5, 86, 44, 2, 151, 152, 7, 174, 2, 2,
	152, 153, 7, 177, 2, 2, 153, 154, 7, 72, 2, 2, 154, 155, 7, 3, 2, 2, 155,
	156, 5, 20, 11, 2, 156, 157, 7, 4, 2, 2, 157, 192, 3, 2, 2, 2, 158, 159,
	7, 53, 2, 2, 159, 192, 5, 86, 44, 2, 160, 161, 7, 52, 2, 2, 161, 192, 5,
	86, 44, 2, 162, 163, 7, 174, 2, 2, 163, 170, 7, 76, 2, 2, 164, 165, 7,
	106, 2, 2, 165, 168, 5, 60, 31, 2, 166, 167, 7, 60, 2, 2, 167, 169, 5,
	60, 31, 2, 168, 166, 3, 2, 2, 2, 168, 169, 3, 2, 2, 2, 169, 171, 3, 2,
	2, 2, 170, 164, 3, 2, 2, 2, 170, 171, 3, 2, 2, 2, 171, 192, 3, 2, 2, 2,
	172, 173, 7, 174, 2, 2, 173, 180, 7, 171, 2, 2, 174, 175, 7, 106, 2, 2,
	175, 178, 5, 60, 31, 2, 176, 177, 7, 60, 2, 2, 177, 179, 5, 60, 31, 2,
	178, 176, 3, 2, 2, 2, 178, 179, 3, 2, 2, 2, 179, 181, 3, 2, 2, 2, 180,
	174, 3, 2, 2, 2, 180, 181, 3, 2, 2, 2, 181, 192, 3, 2, 2, 2, 182, 183,
	7, 172, 2, 2, 183, 184, 7, 171, 2, 2, 184, 185, 5, 86, 44, 2, 185, 186,
	7, 213, 2, 2, 186, 187, 5, 50, 26, 2, 187, 192, 3, 2, 2, 2, 188, 189, 7,
	154, 2, 2, 189, 190, 7, 171, 2, 2, 190, 192, 5, 86, 44, 2, 191, 94, 3,
	2, 2, 2, 191, 95, 3, 2, 2, 2, 191, 109, 3, 2, 2, 2, 191, 123, 3, 2, 2,
	2, 191, 133, 3, 2, 2, 2, 191, 147, 3, 2, 2, 2, 191, 151, 3, 2, 2, 2, 191,
	158, 3, 2, 2, 2, 191, 160, 3, 2, 2, 2, 191, 162, 3, 2, 2, 2, 191, 172,
	3, 2, 2, 2, 191, 182, 3, 2, 2, 2, 191, 188, 3, 2, 2, 2, 192, 3, 3, 2, 2,
	2, 193, 195, 5, 6, 4, 2, 194, 193, 3, 2, 2, 2, 194, 195, 3, 2, 2, 2, 195,
	196, 3, 2, 2, 2, 196, 197, 5, 8, 5, 2, 197, 5, 3, 2, 2, 2, 198, 200, 7,
	207, 2, 2, 199, 201, 7, 149, 2, 2, 200, 199, 3, 2, 2, 2, 200, 201, 3, 2,
	2, 2, 201, 202, 3, 2, 2, 2, 202, 207, 5, 28, 15, 2, 203, 204, 7, 5, 2,
	2, 204, 206, 5, 28, 15, 2, 205, 203, 3, 2, 2, 2, 206, 209, 3, 2, 2, 2,
	207, 205, 3, 2, 2, 2, 207, 208, 3, 2, 2, 2, 208, 7, 3, 2, 2, 2, 209, 207,
	3, 2, 2, 2, 210, 221, 5, 14, 8, 2, 211, 212, 7, 133, 2, 2, 212, 213, 7,
	24, 2, 2, 213, 218, 5, 18, 10, 2, 214, 215, 7, 5, 2, 2, 215, 217, 5, 18,
	10, 2, 216, 214, 3, 2, 2, 2, 217, 220, 3, 2, 2, 2, 218, 216, 3, 2, 2, 2,
	218, 219, 3, 2, 2, 2, 219, 222, 3, 2, 2, 2, 220, 218, 3, 2, 2, 2, 221,
	211, 3, 2, 2, 2, 221, 222, 3, 2, 2, 2, 222, 228, 3, 2, 2, 2, 223, 224,
	7, 128, 2, 2, 224, 226, 5, 12, 7, 2, 225, 227, 9, 3, 2, 2, 226, 225, 3,
	2, 2, 2, 226, 227, 3, 2, 2, 2, 227, 229, 3, 2, 2, 2, 228, 223, 3, 2, 2,
	2, 228, 229, 3, 2, 2, 2, 229, 243, 3, 2, 2, 2, 230, 231, 7, 107, 2, 2,
	231, 244, 5, 10, 6, 2, 232, 233, 7, 68, 2, 2, 233, 235, 9, 4, 2, 2, 234,
	236, 5, 12, 7, 2, 235, 234, 3, 2, 2, 2, 235, 236, 3, 2, 2, 2, 236, 237,
	3, 2, 2, 2, 237, 241, 9, 3, 2, 2, 238, 242, 7, 130, 2, 2, 239, 240, 7,
	207, 2, 2, 240, 242, 7, 185, 2, 2, 241, 238, 3, 2, 2, 2, 241, 239, 3, 2,
	2, 2, 242, 244, 3, 2, 2, 2, 243, 230, 3, 2, 2, 2, 243, 232, 3, 2, 2, 2,
	243, 244, 3, 2, 2, 2, 244, 9, 3, 2, 2, 2, 245, 248, 7, 12, 2, 2, 246, 248,
	5, 12, 7, 2, 247, 245, 3, 2, 2, 2, 247, 246, 3, 2, 2, 2, 248, 11, 3, 2,
	2, 2, 249, 250, 9, 5, 2, 2, 250, 13, 3, 2, 2, 2, 251, 252, 8, 8, 1, 2,
	252, 253, 5, 16, 9, 2, 253, 268, 3, 2, 2, 2, 254, 255, 12, 4, 2, 2, 255,
	257, 7, 93, 2, 2, 256, 258, 5, 30, 16, 2, 257, 256, 3, 2, 2, 2, 257, 258,
	3, 2, 2, 2, 258, 259, 3, 2, 2, 2, 259, 267, 5, 14, 8, 5, 260, 261, 12,
	3, 2, 2, 261, 263, 9, 6, 2, 2, 262, 264, 5, 30, 16, 2, 263, 262, 3, 2,
	2, 2, 263, 264, 3, 2, 2, 2, 264, 265, 3, 2, 2, 2, 265, 267, 5, 14, 8, 4,
	266, 254, 3, 2, 2, 2, 266, 260, 3, 2, 2, 2, 267, 270, 3, 2, 2, 2, 268,
	266, 3, 2, 2, 2, 268, 269, 3, 2, 2, 2, 269, 15, 3, 2, 2, 2, 270, 268, 3,
	2, 2, 2, 271, 288, 5, 20, 11, 2, 272, 273, 7, 180, 2, 2, 273, 288, 5, 86,
	44, 2, 274, 275, 7, 202, 2, 2, 275, 280, 5, 50, 26, 2, 276, 277, 7, 5,
	2, 2, 277, 279, 5, 50, 26, 2, 278, 276, 3, 2, 2, 2, 279, 282, 3, 2, 2,
	2, 280, 278, 3, 2, 2, 2, 280, 281, 3, 2, 2, 2, 281, 288, 3, 2, 2, 2, 282,
	280, 3, 2, 2, 2, 283, 284, 7, 3, 2, 2, 284, 285, 5, 8, 5, 2, 285, 286,
	7, 4, 2, 2, 286, 288, 3, 2, 2, 2, 287, 271, 3, 2, 2, 2, 287, 272, 3, 2,
	2, 2, 287, 274, 3, 2, 2, 2, 287, 283, 3, 2, 2, 2, 288, 17, 3, 2, 2, 2,
	289, 291, 5, 50, 26, 2, 290, 292, 9, 7, 2, 2, 291, 290, 3, 2, 2, 2, 291,
	292, 3, 2, 2, 2, 292, 295, 3, 2, 2, 2, 293, 294, 7, 127, 2, 2, 294, 296,
	9, 8, 2, 2, 295, 293, 3, 2, 2, 2, 295, 296, 3, 2, 2, 2, 296, 19, 3, 2,
	2, 2, 297, 299, 7, 169, 2, 2, 298, 300, 5, 30, 16, 2, 299, 298, 3, 2, 2,
	2, 299, 300, 3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 306, 5, 32, 17, 2,
	302, 303, 7, 5, 2, 2, 303, 305, 5, 32, 17, 2, 304, 302, 3, 2, 2, 2, 305,
	308, 3, 2, 2, 2, 306, 304, 3, 2, 2, 2, 306, 307, 3, 2, 2, 2, 307, 318,
	3, 2, 2, 2, 308, 306, 3, 2, 2, 2, 309, 310, 7, 74, 2, 2, 310, 315, 5, 34,
	18, 2, 311, 312, 7, 5, 2, 2, 312, 314, 5, 34, 18, 2, 313, 311, 3, 2, 2,
	2, 314, 317, 3, 2, 2, 2, 315, 313, 3, 2, 2, 2, 315, 316, 3, 2, 2, 2, 316,
	319, 3, 2, 2, 2, 317, 315, 3, 2, 2, 2, 318, 309, 3, 2, 2, 2, 318, 319,
	3, 2, 2, 2, 319, 322, 3, 2, 2, 2, 320, 321, 7, 206, 2, 2, 321, 323, 5,
	52, 27, 2, 322, 320, 3, 2, 2, 2, 322, 323, 3, 2, 2, 2, 323, 327, 3, 2,
	2, 2, 324, 325, 7, 81, 2, 2, 325, 326, 7, 24, 2, 2, 326, 328, 5, 22, 12,
	2, 327, 324, 3, 2, 2, 2, 327, 328, 3, 2, 2, 2, 328, 331, 3, 2, 2, 2, 329,
	330, 7, 84, 2, 2, 330, 332, 5, 52, 27, 2, 331, 329, 3, 2, 2, 2, 331, 332,
	3, 2, 2, 2, 332, 21, 3, 2, 2, 2, 333, 335, 5, 30, 16, 2, 334, 333, 3, 2,
	2, 2, 334, 335, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 341, 5, 24, 13,
	2, 337, 338, 7, 5, 2, 2, 338, 340, 5, 24, 13, 2, 339, 337, 3, 2, 2, 2,
	340, 343, 3, 2, 2, 2, 341, 339, 3, 2, 2, 2, 341, 342, 3, 2, 2, 2, 342,
	23, 3, 2, 2, 2, 343, 341, 3, 2, 2, 2, 344, 385, 5, 26, 14, 2, 345, 346,
	7, 162, 2, 2, 346, 355, 7, 3, 2, 2, 347, 352, 5, 50, 26, 2, 348, 349, 7,
	5, 2, 2, 349, 351, 5, 50, 26, 2, 350, 348, 3, 2, 2, 2, 351, 354, 3, 2,
	2, 2, 352, 350, 3, 2, 2, 2, 352, 353, 3, 2, 2, 2, 353, 356, 3, 2, 2, 2,
	354, 352, 3, 2, 2, 2, 355, 347, 3, 2, 2, 2, 355, 356, 3, 2, 2, 2, 356,
	357, 3, 2, 2, 2, 357, 385, 7, 4, 2, 2, 358, 359, 7, 38, 2, 2, 359, 368,
	7, 3, 2, 2, 360, 365, 5, 50, 26, 2, 361, 362, 7, 5, 2, 2, 362, 364, 5,
	50, 26, 2, 363, 361, 3, 2, 2, 2, 364, 367, 3, 2, 2, 2, 365, 363, 3, 2,
	2, 2, 365, 366, 3, 2, 2, 2, 366, 369, 3, 2, 2, 2, 367, 365, 3, 2, 2, 2,
	368, 360, 3, 2, 2, 2, 368, 369, 3, 2, 2, 2, 369, 370, 3, 2, 2, 2, 370,
	385, 7, 4, 2, 2, 371, 372, 7, 82, 2, 2, 372, 373, 7, 173, 2, 2, 373, 374,
	7, 3, 2, 2, 374, 379, 5, 26, 14, 2, 375, 376, 7, 5, 2, 2, 376, 378, 5,
	26, 14, 2, 377, 375, 3, 2, 2, 2, 378, 381, 3, 2, 2, 2, 379, 377, 3, 2,
	2, 2, 379, 380, 3, 2, 2, 2, 380, 382, 3, 2, 2, 2, 381, 379, 3, 2, 2, 2,
	382, 383, 7, 4, 2, 2, 383, 385, 3, 2, 2, 2, 384, 344, 3, 2, 2, 2, 384,
	345, 3, 2, 2, 2, 384, 358, 3, 2, 2, 2, 384, 371, 3, 2, 2, 2, 385, 25, 3,
	2, 2, 2, 386, 395, 7, 3, 2, 2, 387, 392, 5, 50, 26, 2, 388, 389, 7, 5,
	2, 2, 389, 391, 5, 50, 26, 2, 390, 388, 3, 2, 2, 2, 391, 394, 3, 2, 2,
	2, 392, 390, 3, 2, 2, 2, 392, 393, 3, 2, 2, 2, 393, 396, 3, 2, 2, 2, 394,
	392, 3, 2, 2, 2, 395, 387, 3, 2, 2, 2, 395, 396, 3, 2, 2, 2, 396, 397,
	3, 2, 2, 2, 397, 400, 7, 4, 2, 2, 398, 400, 5, 50, 26, 2, 399, 386, 3,
	2, 2, 2, 399, 398, 3, 2, 2, 2, 400, 27, 3, 2, 2, 2, 401, 403, 5, 88, 45,
	2, 402, 404, 5, 46, 24, 2, 403, 402, 3, 2, 2, 2, 403, 404, 3, 2, 2, 2,
	404, 405, 3, 2, 2, 2, 405, 406, 7, 18, 2, 2, 406, 407, 7, 3, 2, 2, 407,
	408, 5, 4, 3, 2, 408, 409, 7, 4, 2, 2, 409, 29, 3, 2, 2, 2, 410, 411, 9,
	9, 2, 2, 411, 31, 3, 2, 2, 2, 412, 417, 5, 50, 26, 2, 413, 415, 7, 18,
	2, 2, 414, 413, 3, 2, 2, 2, 414, 415, 3, 2, 2, 2, 415, 416, 3, 2, 2, 2,
	416, 418, 5, 88, 45, 2, 417, 414, 3, 2, 2, 2, 417, 418, 3, 2, 2, 2, 418,
	428, 3, 2, 2, 2, 419, 420, 5, 58, 30, 2, 420, 421, 7, 6, 2, 2, 421, 424,
	7, 221, 2, 2, 422, 423, 7, 18, 2, 2, 423, 425, 5, 46, 24, 2, 424, 422,
	3, 2, 2, 2, 424, 425, 3, 2, 2, 2, 425, 428, 3, 2, 2, 2, 426, 428, 7, 221,
	2, 2, 427, 412, 3, 2, 2, 2, 427, 419, 3, 2, 2, 2, 427, 426, 3, 2, 2, 2,
	428, 33, 3, 2, 2, 2, 429, 430, 8, 18, 1, 2, 430, 431, 5, 40, 21, 2, 431,
	450, 3, 2, 2, 2, 432, 446, 12, 4, 2, 2, 433, 434, 7, 37, 2, 2, 434, 435,
	7, 100, 2, 2, 435, 447, 5, 40, 21, 2, 436, 437, 5, 36, 19, 2, 437, 438,
	7, 100, 2, 2, 438, 439, 5, 34, 18, 2, 439, 440, 5, 38, 20, 2, 440, 447,
	3, 2, 2, 2, 441, 442, 7, 115, 2, 2, 442, 443, 5, 36, 19, 2, 443, 444, 7,
	100, 2, 2, 444, 445, 5, 40, 21, 2, 445, 447, 3, 2, 2, 2, 446, 433, 3, 2,
	2, 2, 446, 436, 3, 2, 2, 2, 446, 441, 3, 2, 2, 2, 447, 449, 3, 2, 2, 2,
	448, 432, 3, 2, 2, 2, 449, 452, 3, 2, 2, 2, 450, 448, 3, 2, 2, 2, 450,
	451, 3, 2, 2, 2, 451, 35, 3, 2, 2, 2, 452, 450, 3, 2, 2, 2, 453, 455, 7,
	90, 2, 2, 454, 453, 3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455, 469, 3, 2, 2,
	2, 456, 458, 7, 104, 2, 2, 457, 459, 7, 135, 2, 2, 458, 457, 3, 2, 2, 2,
	458, 459, 3, 2, 2, 2, 459, 469, 3, 2, 2, 2, 460, 462, 7, 158, 2, 2, 461,
	463, 7, 135, 2, 2, 462, 461, 3, 2, 2, 2, 462, 463, 3, 2, 2, 2, 463, 469,
	3, 2, 2, 2, 464, 466, 7, 75, 2, 2, 465, 467, 7, 135, 2, 2, 466, 465, 3,
	2, 2, 2, 466, 467, 3, 2, 2, 2, 467, 469, 3, 2, 2, 2, 468, 454, 3, 2, 2,
	2, 468, 456, 3, 2, 2, 2, 468, 460, 3, 2, 2, 2, 468, 464, 3, 2, 2, 2, 469,
	37, 3, 2, 2, 2, 470, 471, 7, 129, 2, 2, 471, 485, 5, 52, 27, 2, 472, 473,
	7, 200, 2, 2, 473, 474, 7, 3, 2, 2, 474, 479, 5, 88, 45, 2, 475, 476, 7,
	5, 2, 2, 476, 478, 5, 88, 45, 2, 477, 475, 3, 2, 2, 2, 478, 481, 3, 2,
	2, 2, 479, 477, 3, 2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 482, 3, 2, 2, 2,
	481, 479, 3, 2, 2, 2, 482, 483, 7, 4, 2, 2, 483, 485, 3, 2, 2, 2, 484,
	470, 3, 2, 2, 2, 484, 472, 3, 2, 2, 2, 485, 39, 3, 2, 2, 2, 486, 493, 5,
	44, 23, 2, 487, 488, 7, 182, 2, 2, 488, 489, 5, 42, 22, 2, 489, 490, 7,
	3, 2, 2, 490, 491, 5, 50, 26, 2, 491, 492, 7, 4, 2, 2, 492, 494, 3, 2,
	2, 2, 493, 487, 3, 2, 2, 2, 493, 494, 3, 2, 2, 2, 494, 41, 3, 2, 2, 2,
	495, 496, 9, 10, 2, 2, 496, 43, 3, 2, 2, 2, 497, 505, 5, 48, 25, 2, 498,
	500, 7, 18, 2, 2, 499, 498, 3, 2, 2, 2, 499, 500, 3, 2, 2, 2, 500, 501,
	3, 2, 2, 2, 501, 503, 5, 88, 45, 2, 502, 504, 5, 46, 24, 2, 503, 502, 3,
	2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 506, 3, 2, 2, 2, 505, 499, 3, 2, 2,
	2, 505, 506, 3, 2, 2, 2, 506, 45, 3, 2, 2, 2, 507, 508, 7, 3, 2, 2, 508,
	513, 5, 88, 45, 2, 509, 510, 7, 5, 2, 2, 510, 512, 5, 88, 45, 2, 511, 509,
	3, 2, 2, 2, 512, 515, 3, 2, 2, 2, 513, 511, 3, 2, 2, 2, 513, 514, 3, 2,
	2, 2, 514, 516, 3, 2, 2, 2, 515, 513, 3, 2, 2, 2, 516, 517, 7, 4, 2, 2,
	517, 47, 3, 2, 2, 2, 518, 548, 5, 86, 44, 2, 519, 520, 7, 3, 2, 2, 520,
	521, 5, 4, 3, 2, 521, 522, 7, 4, 2, 2, 522, 548, 3, 2, 2, 2, 523, 524,
	7, 197, 2, 2, 524, 525, 7, 3, 2, 2, 525, 530, 5, 50, 26, 2, 526, 527, 7,
	5, 2, 2, 527, 529, 5, 50, 26, 2, 528, 526, 3, 2, 2, 2, 529, 532, 3, 2,
	2, 2, 530, 528, 3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531, 533, 3, 2, 2, 2,
	532, 530, 3, 2, 2, 2, 533, 536, 7, 4, 2, 2, 534, 535, 7, 207, 2, 2, 535,
	537, 7, 134, 2, 2, 536, 534, 3, 2, 2, 2, 536, 537, 3, 2, 2, 2, 537, 548,
	3, 2, 2, 2, 538, 539, 7, 103, 2, 2, 539, 540, 7, 3, 2, 2, 540, 541, 5,
	4, 3, 2, 541, 542, 7, 4, 2, 2, 542, 548, 3, 2, 2, 2, 543, 544, 7, 3, 2,
	2, 544, 545, 5, 34, 18, 2, 545, 546, 7, 4, 2, 2, 546, 548, 3, 2, 2, 2,
	547, 518, 3, 2, 2, 2, 547, 519, 3, 2, 2, 2, 547, 523, 3, 2, 2, 2, 547,
	538, 3, 2, 2, 2, 547, 543, 3, 2, 2, 2, 548, 49, 3, 2, 2, 2, 549, 550, 5,
	52, 27, 2, 550, 51, 3, 2, 2, 2, 551, 552, 8, 27, 1, 2, 552, 554, 5, 56,
	29, 2, 553, 555, 5, 54, 28, 2, 554, 553, 3, 2, 2, 2, 554, 555, 3, 2, 2,
	2, 555, 559, 3, 2, 2, 2, 556, 557, 7, 124, 2, 2, 557, 559, 5, 52, 27, 5,
	558, 551, 3, 2, 2, 2, 558, 556, 3, 2, 2, 2, 559, 568, 3, 2, 2, 2, 560,
	561, 12, 4, 2, 2, 561, 562, 7, 15, 2, 2, 562, 567, 5, 52, 27, 5, 563, 564,
	12, 3, 2, 2, 564, 565, 7, 132, 2, 2, 565, 567, 5, 52, 27, 4, 566, 560,
	3, 2, 2, 2, 566, 563, 3, 2, 2, 2, 567, 570, 3, 2, 2, 2, 568, 566, 3, 2,
	2, 2, 568, 569, 3, 2, 2, 2, 569, 53, 3, 2, 2, 2, 570, 568, 3, 2, 2, 2,
	571, 572, 5, 64, 33, 2, 572, 573, 5, 56, 29, 2, 573, 633, 3, 2, 2, 2, 574,
	575, 5, 64, 33, 2, 575, 576, 5, 66, 34, 2, 576, 577, 7, 3, 2, 2, 577, 578,
	5, 4, 3, 2, 578, 579, 7, 4, 2, 2, 579, 633, 3, 2, 2, 2, 580, 582, 7, 124,
	2, 2, 581, 580, 3, 2, 2, 2, 581, 582, 3, 2, 2, 2, 582, 583, 3, 2, 2, 2,
	583, 584, 7, 23, 2, 2, 584, 585, 5, 56, 29, 2, 585, 586, 7, 15, 2, 2, 586,
	587, 5, 56, 29, 2, 587, 633, 3, 2, 2, 2, 588, 590, 7, 124, 2, 2, 589, 588,
	3, 2, 2, 2, 589, 590, 3, 2, 2, 2, 590, 591, 3, 2, 2, 2, 591, 592, 7, 88,
	2, 2, 592, 593, 7, 3, 2, 2, 593, 598, 5, 50, 26, 2, 594, 595, 7, 5, 2,
	2, 595, 597, 5, 50, 26, 2, 596, 594, 3, 2, 2, 2, 597, 600, 3, 2, 2, 2,
	598, 596, 3, 2, 2, 2, 598, 599, 3, 2, 2, 2, 599, 601, 3, 2, 2, 2, 600,
	598, 3, 2, 2, 2, 601, 602, 7, 4, 2, 2, 602, 633, 3, 2, 2, 2, 603, 605,
	7, 124, 2, 2, 604, 603, 3, 2, 2, 2, 604, 605, 3, 2, 2, 2, 605, 606, 3,
	2, 2, 2, 606, 607, 7, 88, 2, 2, 607, 608, 7, 3, 2, 2, 608, 609, 5, 4, 3,
	2, 609, 610, 7, 4, 2, 2, 610, 633, 3, 2, 2, 2, 611, 613, 7, 124, 2, 2,
	612, 611, 3, 2, 2, 2, 612, 613, 3, 2, 2, 2, 613, 614, 3, 2, 2, 2, 614,
	615, 7, 106, 2, 2, 615, 618, 5, 56, 29, 2, 616, 617, 7, 60, 2, 2, 617,
	619, 5, 56, 29, 2, 618, 616, 3, 2, 2, 2, 618, 619, 3, 2, 2, 2, 619, 633,
	3, 2, 2, 2, 620, 622, 7, 98, 2, 2, 621, 623, 7, 124, 2, 2, 622, 621, 3,
	2, 2, 2, 622, 623, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624, 633, 7, 125,
	2, 2, 625, 627, 7, 98, 2, 2, 626, 628, 7, 124, 2, 2, 627, 626, 3, 2, 2,
	2, 627, 628, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 630, 7, 54, 2, 2, 630,
	631, 7, 74, 2, 2, 631, 633, 5, 56, 29, 2, 632, 571, 3, 2, 2, 2, 632, 574,
	3, 2, 2, 2, 632, 581, 3, 2, 2, 2, 632, 589, 3, 2, 2, 2, 632, 604, 3, 2,
	2, 2, 632, 612, 3, 2, 2, 2, 632, 620, 3, 2, 2, 2, 632, 625, 3, 2, 2, 2,
	633, 55, 3, 2, 2, 2, 634, 635, 8, 29, 1, 2, 635, 639, 5, 58, 30, 2, 636,
	637, 9, 11, 2, 2, 637, 639, 5, 56, 29, 6, 638, 634, 3, 2, 2, 2, 638, 636,
	3, 2, 2, 2, 639, 654, 3, 2, 2, 2, 640, 641, 12, 5, 2, 2, 641, 642, 9, 12,
	2, 2, 642, 653, 5, 56, 29, 6, 643, 644, 12, 4, 2, 2, 644, 645, 9, 11, 2,
	2, 645, 653, 5, 56, 29, 5, 646, 647, 12, 3, 2, 2, 647, 648, 7, 224, 2,
	2, 648, 653, 5, 56, 29, 4, 649, 650, 12, 7, 2, 2, 650, 651, 7, 20, 2, 2,
	651, 653, 5, 62, 32, 2, 652, 640, 3, 2, 2, 2, 652, 643, 3, 2, 2, 2, 652,
	646, 3, 2, 2, 2, 652, 649, 3, 2, 2, 2, 653, 656, 3, 2, 2, 2, 654, 652,
	3, 2, 2, 2, 654, 655, 3, 2, 2, 2, 655, 57, 3, 2, 2, 2, 656, 654, 3, 2,
	2, 2, 657, 658, 8, 30, 1, 2, 658, 890, 7, 125, 2, 2, 659, 890, 5, 70, 36,
	2, 660, 661, 5, 88, 45, 2, 661, 662, 5, 60, 31, 2, 662, 890, 3, 2, 2, 2,
	663, 664, 7, 56, 2, 2, 664, 665, 7, 143, 2, 2, 665, 890, 5, 60, 31, 2,
	666, 890, 5, 90, 46, 2, 667, 890, 5, 68, 35, 2, 668, 890, 5, 60, 31, 2,
	669, 890, 7, 227, 2, 2, 670, 890, 7, 238, 2, 2, 671, 672, 7, 141, 2, 2,
	672, 673, 7, 3, 2, 2, 673, 674, 5, 56, 29, 2, 674, 675, 7, 88, 2, 2, 675,
	676, 5, 56, 29, 2, 676, 677, 7, 4, 2, 2, 677, 890, 3, 2, 2, 2, 678, 679,
	7, 3, 2, 2, 679, 682, 5, 50, 26, 2, 680, 681, 7, 5, 2, 2, 681, 683, 5,
	50, 26, 2, 682, 680, 3, 2, 2, 2, 683, 684, 3, 2, 2, 2, 684, 682, 3, 2,
	2, 2, 684, 685, 3, 2, 2, 2, 685, 686, 3, 2, 2, 2, 686, 687, 7, 4, 2, 2,
	687, 890, 3, 2, 2, 2, 688, 689, 7, 163, 2, 2, 689, 690, 7, 3, 2, 2, 690,
	695, 5, 50, 26, 2, 691, 692, 7, 5, 2, 2, 692, 694, 5, 50, 26, 2, 693, 691,
	3, 2, 2, 2, 694, 697, 3, 2, 2, 2, 695, 693, 3, 2, 2, 2, 695, 696, 3, 2,
	2, 2, 696, 698, 3, 2, 2, 2, 697, 695, 3, 2, 2, 2, 698, 699, 7, 4, 2, 2,
	699, 890, 3, 2, 2, 2, 700, 701, 5, 86, 44, 2, 701, 702, 7, 3, 2, 2, 702,
	703, 7, 221, 2, 2, 703, 705, 7, 4, 2, 2, 704, 706, 5, 84, 43, 2, 705, 704,
	3, 2, 2, 2, 705, 706, 3, 2, 2, 2, 706, 890, 3, 2, 2, 2, 707, 708, 5, 86,
	44, 2, 708, 720, 7, 3, 2, 2, 709, 711, 5, 30, 16, 2, 710, 709, 3, 2, 2,
	2, 710, 711, 3, 2, 2, 2, 711, 712, 3, 2, 2, 2, 712, 717, 5, 50, 26, 2,
	713, 714, 7, 5, 2, 2, 714, 716, 5, 50, 26, 2, 715, 713, 3, 2, 2, 2, 716,
	719, 3, 2, 2, 2, 717, 715, 3, 2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 721,
	3, 2, 2, 2, 719, 717, 3, 2, 2, 2, 720, 710, 3, 2, 2, 2, 720, 721, 3, 2,
	2, 2, 721, 732, 3, 2, 2, 2, 722, 723, 7, 133, 2, 2, 723, 724, 7, 24, 2,
	2, 724, 729, 5, 18, 10, 2, 725, 726, 7, 5, 2, 2, 726, 728, 5, 18, 10, 2,
	727, 725, 3, 2, 2, 2, 728, 731, 3, 2, 2, 2, 729, 727, 3, 2, 2, 2, 729,
	730, 3, 2, 2, 2, 730, 733, 3, 2, 2, 2, 731, 729, 3, 2, 2, 2, 732, 722,
	3, 2, 2, 2, 732, 733, 3, 2, 2, 2, 733, 734, 3, 2, 2, 2, 734, 736, 7, 4,
	2, 2, 735, 737, 5, 84, 43, 2, 736, 735, 3, 2, 2, 2, 736, 737, 3, 2, 2,
	2, 737, 890, 3, 2, 2, 2, 738, 739, 5, 88, 45, 2, 739, 740, 7, 7, 2, 2,
	740, 741, 5, 50, 26, 2, 741, 890, 3, 2, 2, 2, 742, 751, 7, 3, 2, 2, 743,
	748, 5, 88, 45, 2, 744, 745, 7, 5, 2, 2, 745, 747, 5, 88, 45, 2, 746, 744,
	3, 2, 2, 2, 747, 750, 3, 2, 2, 2, 748, 746, 3, 2, 2, 2, 748, 749, 3, 2,
	2, 2, 749, 752, 3, 2, 2, 2, 750, 748, 3, 2, 2, 2, 751, 743, 3, 2, 2, 2,
	751, 752, 3, 2, 2, 2, 752, 753, 3, 2, 2, 2, 753, 754, 7, 4, 2, 2, 754,
	755, 7, 7, 2, 2, 755, 890, 5, 50, 26, 2, 756, 757, 7, 3, 2, 2, 757, 758,
	5, 4, 3, 2, 758, 759, 7, 4, 2, 2, 759, 890, 3, 2, 2, 2, 760, 761, 7, 64,
	2, 2, 761, 762, 7, 3, 2, 2, 762, 763, 5, 4, 3, 2, 763, 764, 7, 4, 2, 2,
	764, 890, 3, 2, 2, 2, 765, 766, 7, 27, 2, 2, 766, 768, 5, 50, 26, 2, 767,
	769, 5, 82, 42, 2, 768, 767, 3, 2, 2, 2, 769, 770, 3, 2, 2, 2, 770, 768,
	3, 2, 2, 2, 770, 771, 3, 2, 2, 2, 771, 774, 3, 2, 2, 2, 772, 773, 7, 58,
	2, 2, 773, 775, 5, 50, 26, 2, 774, 772, 3, 2, 2, 2, 774, 775, 3, 2, 2,
	2, 775, 776, 3, 2, 2, 2, 776, 777, 7, 59, 2, 2, 777, 890, 3, 2, 2, 2, 778,
	780, 7, 27, 2, 2, 779, 781, 5, 82, 42, 2, 780, 779, 3, 2, 2, 2, 781, 782,
	3, 2, 2, 2, 782, 780, 3, 2, 2, 2, 782, 783, 3, 2, 2, 2, 783, 786, 3, 2,
	2, 2, 784, 785, 7, 58, 2, 2, 785, 787, 5, 50, 26, 2, 786, 784, 3, 2, 2,
	2, 786, 787, 3, 2, 2, 2, 787, 788, 3, 2, 2, 2, 788, 789, 7, 59, 2, 2, 789,
	890, 3, 2, 2, 2, 790, 791, 7, 28, 2, 2, 791, 792, 7, 3, 2, 2, 792, 793,
	5, 50, 26, 2, 793, 794, 7, 18, 2, 2, 794, 795, 5, 76, 39, 2, 795, 796,
	7, 4, 2, 2, 796, 890, 3, 2, 2, 2, 797, 798, 7, 191, 2, 2, 798, 799, 7,
	3, 2, 2, 799, 800, 5, 50, 26, 2, 800, 801, 7, 18, 2, 2, 801, 802, 5, 76,
	39, 2, 802, 803, 7, 4, 2, 2, 803, 890, 3, 2, 2, 2, 804, 805, 7, 17, 2,
	2, 805, 814, 7, 8, 2, 2, 806, 811, 5, 50, 26, 2, 807, 808, 7, 5, 2, 2,
	808, 810, 5, 50, 26, 2, 809, 807, 3, 2, 2, 2, 810, 813, 3, 2, 2, 2, 811,
	809, 3, 2, 2, 2, 811, 812, 3, 2, 2, 2, 812, 815, 3, 2, 2, 2, 813, 811,
	3, 2, 2, 2, 814, 806, 3, 2, 2, 2, 814, 815, 3, 2, 2, 2, 815, 816, 3, 2,
	2, 2, 816, 890, 7, 9, 2, 2, 817, 890, 5, 88, 45, 2, 818, 890, 7, 40, 2,
	2, 819, 823, 7, 43, 2, 2, 820, 821, 7, 3, 2, 2, 821, 822, 7, 228, 2, 2,
	822, 824, 7, 4, 2, 2, 823, 820, 3, 2, 2, 2, 823, 824, 3, 2, 2, 2, 824,
	890, 3, 2, 2, 2, 825, 829, 7, 44, 2, 2, 826, 827, 7, 3, 2, 2, 827, 828,
	7, 228, 2, 2, 828, 830, 7, 4, 2, 2, 829, 826, 3, 2, 2, 2, 829, 830, 3,
	2, 2, 2, 830, 890, 3, 2, 2, 2, 831, 835, 7, 108, 2, 2, 832, 833, 7, 3,
	2, 2, 833, 834, 7, 228, 2, 2, 834, 836, 7, 4, 2, 2, 835, 832, 3, 2, 2,
	2, 835, 836, 3, 2, 2, 2, 836, 890, 3, 2, 2, 2, 837, 841, 7, 109, 2, 2,
	838, 839, 7, 3, 2, 2, 839, 840, 7, 228, 2, 2, 840, 842, 7, 4, 2, 2, 841,
	838, 3, 2, 2, 2, 841, 842, 3, 2, 2, 2, 842, 890, 3, 2, 2, 2, 843, 890,
	7, 45, 2, 2, 844, 890, 7, 41, 2, 2, 845, 846, 7, 178, 2, 2, 846, 847, 7,
	3, 2, 2, 847, 848, 5, 56, 29, 2, 848, 849, 7, 74, 2, 2, 849, 852, 5, 56,
	29, 2, 850, 851, 7, 72, 2, 2, 851, 853, 5, 56, 29, 2, 852, 850, 3, 2, 2,
	2, 852, 853, 3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854, 855, 7, 4, 2, 2, 855,
	890, 3, 2, 2, 2, 856, 857, 7, 123, 2, 2, 857, 858, 7, 3, 2, 2, 858, 861,
	5, 56, 29, 2, 859, 860, 7, 5, 2, 2, 860, 862, 5, 74, 38, 2, 861, 859, 3,
	2, 2, 2, 861, 862, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2, 863, 864, 7, 4, 2,
	2, 864, 890, 3, 2, 2, 2, 865, 866, 7, 66, 2, 2, 866, 867, 7, 3, 2, 2, 867,
	868, 5, 88, 45, 2, 868, 869, 7, 74, 2, 2, 869, 870, 5, 56, 29, 2, 870,
	871, 7, 4, 2, 2, 871, 890, 3, 2, 2, 2, 872, 873, 7, 3, 2, 2, 873, 874,
	5, 50, 26, 2, 874, 875, 7, 4, 2, 2, 875, 890, 3, 2, 2, 2, 876, 877, 7,
	82, 2, 2, 877, 886, 7, 3, 2, 2, 878, 883, 5, 86, 44, 2, 879, 880, 7, 5,
	2, 2, 880, 882, 5, 86, 44, 2, 881, 879, 3, 2, 2, 2, 882, 885, 3, 2, 2,
	2, 883, 881, 3, 2, 2, 2, 883, 884, 3, 2, 2, 2, 884, 887, 3, 2, 2, 2, 885,
	883, 3, 2, 2, 2, 886, 878, 3, 2, 2, 2, 886, 887, 3, 2, 2, 2, 887, 888,
	3, 2, 2, 2, 888, 890, 7, 4, 2, 2, 889, 657, 3, 2, 2, 2, 889, 659, 3, 2,
	2, 2, 889, 660, 3, 2, 2, 2, 889, 663, 3, 2, 2, 2, 889, 666, 3, 2, 2, 2,
	889, 667, 3, 2, 2, 2, 889, 668, 3, 2, 2, 2, 889, 669, 3, 2, 2, 2, 889,
	670, 3, 2, 2, 2, 889, 671, 3, 2, 2, 2, 889, 678, 3, 2, 2, 2, 889, 688,
	3, 2, 2, 2, 889, 700, 3, 2, 2, 2, 889, 707, 3, 2, 2, 2, 889, 738, 3, 2,
	2, 2, 889, 742, 3, 2, 2, 2, 889, 756, 3, 2, 2, 2, 889, 760, 3, 2, 2, 2,
	889, 765, 3, 2, 2, 2, 889, 778, 3, 2, 2, 2, 889, 790, 3, 2, 2, 2, 889,
	797, 3, 2, 2, 2, 889, 804, 3, 2, 2, 2, 889, 817, 3, 2, 2, 2, 889, 818,
	3, 2, 2, 2, 889, 819, 3, 2, 2, 2, 889, 825, 3, 2, 2, 2, 889, 831, 3, 2,
	2, 2, 889, 837, 3, 2, 2, 2, 889, 843, 3, 2, 2, 2, 889, 844, 3, 2, 2, 2,
	889, 845, 3, 2, 2, 2, 889, 856, 3, 2, 2, 2, 889, 865, 3, 2, 2, 2, 889,
	872, 3, 2, 2, 2, 889, 876, 3, 2, 2, 2, 890, 901, 3, 2, 2, 2, 891, 892,
	12, 17, 2, 2, 892, 893, 7, 8, 2, 2, 893, 894, 5, 56, 29, 2, 894, 895, 7,
	9, 2, 2, 895, 900, 3, 2, 2, 2, 896, 897, 12, 15, 2, 2, 897, 898, 7, 6,
	2, 2, 898, 900, 5, 88, 45, 2, 899, 891, 3, 2, 2, 2, 899, 896, 3, 2, 2,
	2, 900, 903, 3, 2, 2, 2, 901, 899, 3, 2, 2, 2, 901, 902, 3, 2, 2, 2, 902,
	59, 3, 2, 2, 2, 903, 901, 3, 2, 2, 2, 904, 911, 7, 225, 2, 2, 905, 908,
	7, 226, 2, 2, 906, 907, 7, 193, 2, 2, 907, 909, 7, 225, 2, 2, 908, 906,
	3, 2, 2, 2, 908, 909, 3, 2, 2, 2, 909, 911, 3, 2, 2, 2, 910, 904, 3, 2,
	2, 2, 910, 905, 3, 2, 2, 2, 911, 61, 3, 2, 2, 2, 912, 913, 7, 186, 2, 2,
	913, 914, 7, 212, 2, 2, 914, 919, 5, 70, 36, 2, 915, 916, 7, 186, 2, 2,
	916, 917, 7, 212, 2, 2, 917, 919, 5, 60, 31, 2, 918, 912, 3, 2, 2, 2, 918,
	915, 3, 2, 2, 2, 919, 63, 3, 2, 2, 2, 920, 921, 9, 13, 2, 2, 921, 65, 3,
	2, 2, 2, 922, 923, 9, 14, 2, 2, 923, 67, 3, 2, 2, 2, 924, 925, 9, 15, 2,
	2, 925, 69, 3, 2, 2, 2, 926, 928, 7, 94, 2, 2, 927, 929, 9, 11, 2, 2, 928,
	927, 3, 2, 2, 2, 928, 929, 3, 2, 2, 2, 929, 930, 3, 2, 2, 2, 930, 931,
	5, 60, 31, 2, 931, 934, 5, 72, 37, 2, 932, 933, 7, 188, 2, 2, 933, 935,
	5, 72, 37, 2, 934, 932, 3, 2, 2, 2, 934, 935, 3, 2, 2, 2, 935, 71, 3, 2,
	2, 2, 936, 937, 9, 16, 2, 2, 937, 73, 3, 2, 2, 2, 938, 939, 9, 17, 2, 2,
	939, 75, 3, 2, 2, 2, 940, 941, 8, 39, 1, 2, 941, 942, 7, 163, 2, 2, 942,
	943, 7, 3, 2, 2, 943, 948, 5, 78, 40, 2, 944, 945, 7, 5, 2, 2, 945, 947,
	5, 78, 40, 2, 946, 944, 3, 2, 2, 2, 947, 950, 3, 2, 2, 2, 948, 946, 3,
	2, 2, 2, 948, 949, 3, 2, 2, 2, 949, 951, 3, 2, 2, 2, 950, 948, 3, 2, 2,
	2, 951, 952, 7, 4, 2, 2, 952, 1032, 3, 2, 2, 2, 953, 954, 7, 94, 2, 2,
	954, 957, 5, 72, 37, 2, 955, 956, 7, 188, 2, 2, 956, 958, 5, 72, 37, 2,
	957, 955, 3, 2, 2, 2, 957, 958, 3, 2, 2, 2, 958, 1032, 3, 2, 2, 2, 959,
	964, 7, 187, 2, 2, 960, 961, 7, 3, 2, 2, 961, 962, 5, 80, 41, 2, 962, 963,
	7, 4, 2, 2, 963, 965, 3, 2, 2, 2, 964, 960, 3, 2, 2, 2, 964, 965, 3, 2,
	2, 2, 965, 969, 3, 2, 2, 2, 966, 967, 7, 208, 2, 2, 967, 968, 7, 186, 2,
	2, 968, 970, 7, 212, 2, 2, 969, 966, 3, 2, 2, 2, 969, 970, 3, 2, 2, 2,
	970, 1032, 3, 2, 2, 2, 971, 976, 7, 187, 2, 2, 972, 973, 7, 3, 2, 2, 973,
	974, 5, 80, 41, 2, 974, 975, 7, 4, 2, 2, 975, 977, 3, 2, 2, 2, 976, 972,
	3, 2, 2, 2, 976, 977, 3, 2, 2, 2, 977, 978, 3, 2, 2, 2, 978, 979, 7, 207,
	2, 2, 979, 980, 7, 186, 2, 2, 980, 1032, 7, 212, 2, 2, 981, 986, 7, 186,
	2, 2, 982, 983, 7, 3, 2, 2, 983, 984, 5, 80, 41, 2, 984, 985, 7, 4, 2,
	2, 985, 987, 3, 2, 2, 2, 986, 982, 3, 2, 2, 2, 986, 987, 3, 2, 2, 2, 987,
	991, 3, 2, 2, 2, 988, 989, 7, 208, 2, 2, 989, 990, 7, 186, 2, 2, 990, 992,
	7, 212, 2, 2, 991, 988, 3, 2, 2, 2, 991, 992, 3, 2, 2, 2, 992, 1032, 3,
	2, 2, 2, 993, 998, 7, 186, 2, 2, 994, 995, 7, 3, 2, 2, 995, 996, 5, 80,
	41, 2, 996, 997, 7, 4, 2, 2, 997, 999, 3, 2, 2, 2, 998, 994, 3, 2, 2, 2,
	998, 999, 3, 2, 2, 2, 999, 1000, 3, 2, 2, 2, 1000, 1001, 7, 207, 2, 2,
	1001, 1002, 7, 186, 2, 2, 1002, 1032, 7, 212, 2, 2, 1003, 1004, 7, 56,
	2, 2, 1004, 1032, 7, 143, 2, 2, 1005, 1006, 7, 17, 2, 2, 1006, 1007, 7,
	215, 2, 2, 1007, 1008, 5, 76, 39, 2, 1008, 1009, 7, 217, 2, 2, 1009, 1032,
	3, 2, 2, 2, 1010, 1011, 7, 111, 2, 2, 1011, 1012, 7, 215, 2, 2, 1012, 1013,
	5, 76, 39, 2, 1013, 1014, 7, 5, 2, 2, 1014, 1015, 5, 76, 39, 2, 1015, 1016,
	7, 217, 2, 2, 1016, 1032, 3, 2, 2, 2, 1017, 1029, 5, 88, 45, 2, 1018, 1019,
	7, 3, 2, 2, 1019, 1024, 5, 80, 41, 2, 1020, 1021, 7, 5, 2, 2, 1021, 1023,
	5, 80, 41, 2, 1022, 1020, 3, 2, 2, 2, 1023, 1026, 3, 2, 2, 2, 1024, 1022,
	3, 2, 2, 2, 1024, 1025, 3, 2, 2, 2, 1025, 1027, 3, 2, 2, 2, 1026, 1024,
	3, 2, 2, 2, 1027, 1028, 7, 4, 2, 2, 1028, 1030, 3, 2, 2, 2, 1029, 1018,
	3, 2, 2, 2, 1029, 1030, 3, 2, 2, 2, 1030, 1032, 3, 2, 2, 2, 1031, 940,
	3, 2, 2, 2, 1031, 953, 3, 2, 2, 2, 1031, 959, 3, 2, 2, 2, 1031, 971, 3,
	2, 2, 2, 1031, 981, 3, 2, 2, 2, 1031, 993, 3, 2, 2, 2, 1031, 1003, 3, 2,
	2, 2, 1031, 1005, 3, 2, 2, 2, 1031, 1010, 3, 2, 2, 2, 1031, 1017, 3, 2,
	2, 2, 1032, 1042, 3, 2, 2, 2, 1033, 1034, 12, 4, 2, 2, 1034, 1038, 7, 17,
	2, 2, 1035, 1036, 7, 8, 2, 2, 1036, 1037, 7, 228, 2, 2, 1037, 1039, 7,
	9, 2, 2, 1038, 1035, 3, 2, 2, 2, 1038, 1039, 3, 2, 2, 2, 1039, 1041, 3,
	2, 2, 2, 1040, 1033, 3, 2, 2, 2, 1041, 1044, 3, 2, 2, 2, 1042, 1040, 3,
	2, 2, 2, 1042, 1043, 3, 2, 2, 2, 1043, 77, 3, 2, 2, 2, 1044, 1042, 3, 2,
	2, 2, 1045, 1050, 5, 76, 39, 2, 1046, 1047, 5, 88, 45, 2, 1047, 1048, 5,
	76, 39, 2, 1048, 1050, 3, 2, 2, 2, 1049, 1045, 3, 2, 2, 2, 1049, 1046,
	3, 2, 2, 2, 1050, 79, 3, 2, 2, 2, 1051, 1054, 7, 228, 2, 2, 1052, 1054,
	5, 76, 39, 2, 1053, 1051, 3, 2, 2, 2, 1053, 1052, 3, 2, 2, 2, 1054, 81,
	3, 2, 2, 2, 1055, 1056, 7, 205, 2, 2, 1056, 1057, 5, 50, 26, 2, 1057, 1058,
	7, 184, 2, 2, 1058, 1059, 5, 50, 26, 2, 1059, 83, 3, 2, 2, 2, 1060, 1061,
	7, 69, 2, 2, 1061, 1062, 7, 3, 2, 2, 1062, 1063, 7, 206, 2, 2, 1063, 1064,
	5, 52, 27, 2, 1064, 1065, 7, 4, 2, 2, 1065, 85, 3, 2, 2, 2, 1066, 1071,
	5, 88, 45, 2, 1067, 1068, 7, 6, 2, 2, 1068, 1070, 5, 88, 45, 2, 1069, 1067,
	3, 2, 2, 2, 1070, 1073, 3, 2, 2, 2, 1071, 1069, 3, 2, 2, 2, 1071, 1072,
	3, 2, 2, 2, 1072, 87, 3, 2, 2, 2, 1073, 1071, 3, 2, 2, 2, 1074, 1080, 7,
	231, 2, 2, 1075, 1080, 7, 233, 2, 2, 1076, 1080, 5, 92, 47, 2, 1077, 1080,
	7, 234, 2, 2, 1078, 1080, 7, 232, 2, 2, 1079, 1074, 3, 2, 2, 2, 1079, 1075,
	3, 2, 2, 2, 1079, 1076, 3, 2, 2, 2, 1079, 1077, 3, 2, 2, 2, 1079, 1078,
	3, 2, 2, 2, 1080, 89, 3, 2, 2, 2, 1081, 1083, 7, 220, 2, 2, 1082, 1081,
	3, 2, 2, 2, 1082, 1083, 3, 2, 2, 2, 1083, 1084, 3, 2, 2, 2, 1084, 1094,
	7, 229, 2, 2, 1085, 1087, 7, 220, 2, 2, 1086, 1085, 3, 2, 2, 2, 1086, 1087,
	3, 2, 2, 2, 1087, 1088, 3, 2, 2, 2, 1088, 1094, 7, 230, 2, 2, 1089, 1091,
	7, 220, 2, 2, 1090, 1089, 3, 2, 2, 2, 1090, 1091, 3, 2, 2, 2, 1091, 1092,
	3, 2, 2, 2, 1092, 1094, 7, 228, 2, 2, 1093, 1082, 3, 2, 2, 2, 1093, 1086,
	3, 2, 2, 2, 1093, 1090, 3, 2, 2, 2, 1094, 91, 3, 2, 2, 2, 1095, 1096, 9,
	18, 2, 2, 1096, 93, 3, 2, 2, 2, 147, 99, 105, 107, 113, 119, 121, 129,
	131, 137, 143, 145, 168, 170, 178, 180, 191, 194, 200, 207, 218, 221, 226,
	228, 235, 241, 243, 247, 257, 263, 266, 268, 280, 287, 291, 295, 299, 306,
	315, 318, 322, 327, 331, 334, 341, 352, 355, 365, 368, 379, 384, 392, 395,
	399, 403, 414, 417, 424, 427, 446, 450, 454, 458, 462, 466, 468, 479, 484,
	493, 499, 503, 505, 513, 530, 536, 547, 554, 558, 566, 568, 581, 589, 598,
	604, 612, 618, 622, 627, 632, 638, 652, 654, 684, 695, 705, 710, 717, 720,
	729, 732, 736, 748, 751, 770, 774, 782, 786, 811, 814, 823, 829, 835, 841,
	852, 861, 883, 886, 889, 899, 901, 908, 910, 918, 928, 934, 948, 957, 964,
	969, 976, 986, 991, 998, 1024, 1029, 1031, 1038, 1042, 1049, 1053, 1071,
	1079, 1082, 1086, 1090, 1093,
}
var literalNames = []string{
	"", "'('", "')'", "','", "'.'", "'->'", "'['", "']'", "'ADD'", "'ADMIN'",
	"'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANY'", "'ARRAY'", "'AS'", "'ASC'",
	"'AT'", "'AUTHORIZATION'", "'BERNOULLI'", "'BETWEEN'", "'BY'", "'CALL'",
	"'CASCADE'", "'CASE'", "'CAST'", "'CATALOGS'", "'COLUMN'", "'COLUMNS'",
	"'COMMENT'", "'COMMIT'", "'COMMITTED'", "'CONSTRAINT'", "'CREATE'", "'CROSS'",
	"'CUBE'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_PATH'", "'CURRENT_ROLE'",
	"'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'DATA'", "'DATE'",
	"'DAY'", "'DEALLOCATE'", "'DEFINER'", "'DELETE'", "'DESC'", "'DESCRIBE'",
	"'DISTINCT'", "'DISTRIBUTED'", "'DOUBLE'", "'DROP'", "'ELSE'", "'END'",
	"'ESCAPE'", "'EXCEPT'", "'EXCLUDING'", "'EXECUTE'", "'EXISTS'", "'EXPLAIN'",
	"'EXTRACT'", "'FALSE'", "'FETCH'", "'FILTER'", "'FIRST'", "'FOLLOWING'",
	"'FOR'", "'FORMAT'", "'FROM'", "'FULL'", "'FUNCTIONS'", "'GRANT'", "'GRANTED'",
	"'GRANTS'", "'GRAPHVIZ'", "'GROUP'", "'GROUPING'", "'GROUPS'", "'HAVING'",
	"'HOUR'", "'IF'", "'IGNORE'", "'IN'", "'INCLUDING'", "'INNER'", "'INPUT'",
	"'INSERT'", "'INTERSECT'", "'INTERVAL'", "'INTO'", "'INVOKER'", "'IO'",
	"'IS'", "'ISOLATION'", "'JOIN'", "'JSON'", "'LAST'", "'LATERAL'", "'LEFT'",
	"'LEVEL'", "'LIKE'", "'LIMIT'", "'LOCALTIME'", "'LOCALTIMESTAMP'", "'LOGICAL'",
	"'MAP'", "'MATERIALIZED'", "'MINUTE'", "'MONTH'", "'NATURAL'", "'NEXT'",
	"'NFC'", "'NFD'", "'NFKC'", "'NFKD'", "'NO'", "'NONE'", "'NORMALIZE'",
	"'NOT'", "'NULL'", "'NULLIF'", "'NULLS'", "'OFFSET'", "'ON'", "'ONLY'",
	"'OPTION'", "'OR'", "'ORDER'", "'ORDINALITY'", "'OUTER'", "'OUTPUT'", "'OVER'",
	"'PARTITION'", "'PARTITIONS'", "'PATH'", "'POSITION'", "'PRECEDING'", "'PRECISION'",
	"'PREPARE'", "'PRIVILEGES'", "'PROPERTIES'", "'RANGE'", "'READ'", "'RECURSIVE'",
	"'REFRESH'", "'RENAME'", "'REPEATABLE'", "'REPLACE'", "'RESET'", "'RESPECT'",
	"'RESTRICT'", "'REVOKE'", "'RIGHT'", "'ROLE'", "'ROLES'", "'ROLLBACK'",
	"'ROLLUP'", "'ROW'", "'ROWS'", "'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SECURITY'",
	"'SELECT'", "'SERIALIZABLE'", "'SESSION'", "'SET'", "'SETS'", "'SHOW'",
	"'SOME'", "'START'", "'STATS'", "'SUBSTRING'", "'SYSTEM'", "'TABLE'", "'TABLES'",
	"'TABLESAMPLE'", "'TEXT'", "'THEN'", "'TIES'", "'TIME'", "'TIMESTAMP'",
	"'TO'", "'TRANSACTION'", "'TRUE'", "'TRY_CAST'", "'TYPE'", "'UESCAPE'",
	"'UNBOUNDED'", "'UNCOMMITTED'", "'UNION'", "'UNNEST'", "'USE'", "'USER'",
	"'USING'", "'VALIDATE'", "'VALUES'", "'VERBOSE'", "'VIEW'", "'WHEN'", "'WHERE'",
	"'WITH'", "'WITHOUT'", "'WORK'", "'WRITE'", "'YEAR'", "'ZONE'", "'='",
	"", "'<'", "'<='", "'>'", "'>='", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "'?'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "ADD", "ADMIN", "ALL", "ALTER", "ANALYZE",
	"AND", "ANY", "ARRAY", "AS", "ASC", "AT", "AUTHORIZATION", "BERNOULLI",
	"BETWEEN", "BY", "CALL", "CASCADE", "CASE", "CAST", "CATALOGS", "COLUMN",
	"COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "CONSTRAINT", "CREATE", "CROSS",
	"CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_PATH", "CURRENT_ROLE", "CURRENT_TIME",
	"CURRENT_TIMESTAMP", "CURRENT_USER", "DATA", "DATE", "DAY", "DEALLOCATE",
	"DEFINER", "DELETE", "DESC", "DESCRIBE", "DISTINCT", "DISTRIBUTED", "DOUBLE",
	"DROP", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDING", "EXECUTE", "EXISTS",
	"EXPLAIN", "EXTRACT", "FALSE", "FETCH", "FILTER", "FIRST", "FOLLOWING",
	"FOR", "FORMAT", "FROM", "FULL", "FUNCTIONS", "GRANT", "GRANTED", "GRANTS",
	"GRAPHVIZ", "GROUP", "GROUPING", "GROUPS", "HAVING", "HOUR", "IF", "IGNORE",
	"IN", "INCLUDING", "INNER", "INPUT", "INSERT", "INTERSECT", "INTERVAL",
	"INTO", "INVOKER", "IO", "IS", "ISOLATION", "JOIN", "JSON", "LAST", "LATERAL",
	"LEFT", "LEVEL", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "LOGICAL",
	"MAP", "MATERIALIZED", "MINUTE", "MONTH", "NATURAL", "NEXT", "NFC", "NFD",
	"NFKC", "NFKD", "NO", "NONE", "NORMALIZE", "NOT", "NULL", "NULLIF", "NULLS",
	"OFFSET", "ON", "ONLY", "OPTION", "OR", "ORDER", "ORDINALITY", "OUTER",
	"OUTPUT", "OVER", "PARTITION", "PARTITIONS", "PATH", "POSITION", "PRECEDING",
	"PRECISION", "PREPARE", "PRIVILEGES", "PROPERTIES", "RANGE", "READ", "RECURSIVE",
	"REFRESH", "RENAME", "REPEATABLE", "REPLACE", "RESET", "RESPECT", "RESTRICT",
	"REVOKE", "RIGHT", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS",
	"SCHEMA", "SCHEMAS", "SECOND", "SECURITY", "SELECT", "SERIALIZABLE", "SESSION",
	"SET", "SETS", "SHOW", "SOME", "START", "STATS", "SUBSTRING", "SYSTEM",
	"TABLE", "TABLES", "TABLESAMPLE", "TEXT", "THEN", "TIES", "TIME", "TIMESTAMP",
	"TO", "TRANSACTION", "TRUE", "TRY_CAST", "TYPE", "UESCAPE", "UNBOUNDED",
	"UNCOMMITTED", "UNION", "UNNEST", "USE", "USER", "USING", "VALIDATE", "VALUES",
	"VERBOSE", "VIEW", "WHEN", "WHERE", "WITH", "WITHOUT", "WORK", "WRITE",
	"YEAR", "ZONE", "EQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS", "MINUS",
	"ASTERISK", "SLASH", "PERCENT", "CONCAT", "STRING", "UNICODE_STRING", "BINARY_LITERAL",
	"INTEGER_VALUE", "DECIMAL_VALUE", "DOUBLE_VALUE", "IDENTIFIER", "DIGIT_IDENTIFIER",
	"QUOTED_IDENTIFIER", "BACKQUOTED_IDENTIFIER", "SIMPLE_COMMENT", "BRACKETED_COMMENT",
	"WS", "PARAMETER", "UNRECOGNIZED",
}

var ruleNames = []string{
	"statement", "query", "with", "queryNoWith", "limitRowCount", "rowCount",
	"queryTerm", "queryPrimary", "sortItem", "querySpecification", "groupBy",
	"groupingElement", "groupingSet", "namedQuery", "setQuantifier", "selectItem",
	"relation", "joinType", "joinCriteria", "sampledRelation", "sampleType",
	"aliasedRelation", "columnAliases", "relationPrimary", "expression", "booleanExpression",
	"predicate", "valueExpression", "primaryExpression", "gstring", "timeZoneSpecifier",
	"comparisonOperator", "comparisonQuantifier", "booleanValue", "interval",
	"intervalField", "normalForm", "gtype", "rowField", "typeParameter", "whenClause",
	"filter", "qualifiedName", "identifier", "number", "nonReserved",
}

type SqlBaseParser struct {
	*antlr.BaseParser
}

// NewSqlBaseParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *SqlBaseParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewSqlBaseParser(input antlr.TokenStream) *SqlBaseParser {
	this := new(SqlBaseParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SqlBase.g4"

	return this
}

// SqlBaseParser tokens.
const (
	SqlBaseParserEOF                   = antlr.TokenEOF
	SqlBaseParserT__0                  = 1
	SqlBaseParserT__1                  = 2
	SqlBaseParserT__2                  = 3
	SqlBaseParserT__3                  = 4
	SqlBaseParserT__4                  = 5
	SqlBaseParserT__5                  = 6
	SqlBaseParserT__6                  = 7
	SqlBaseParserADD                   = 8
	SqlBaseParserADMIN                 = 9
	SqlBaseParserALL                   = 10
	SqlBaseParserALTER                 = 11
	SqlBaseParserANALYZE               = 12
	SqlBaseParserAND                   = 13
	SqlBaseParserANY                   = 14
	SqlBaseParserARRAY                 = 15
	SqlBaseParserAS                    = 16
	SqlBaseParserASC                   = 17
	SqlBaseParserAT                    = 18
	SqlBaseParserAUTHORIZATION         = 19
	SqlBaseParserBERNOULLI             = 20
	SqlBaseParserBETWEEN               = 21
	SqlBaseParserBY                    = 22
	SqlBaseParserCALL                  = 23
	SqlBaseParserCASCADE               = 24
	SqlBaseParserCASE                  = 25
	SqlBaseParserCAST                  = 26
	SqlBaseParserCATALOGS              = 27
	SqlBaseParserCOLUMN                = 28
	SqlBaseParserCOLUMNS               = 29
	SqlBaseParserCOMMENT               = 30
	SqlBaseParserCOMMIT                = 31
	SqlBaseParserCOMMITTED             = 32
	SqlBaseParserCONSTRAINT            = 33
	SqlBaseParserCREATE                = 34
	SqlBaseParserCROSS                 = 35
	SqlBaseParserCUBE                  = 36
	SqlBaseParserCURRENT               = 37
	SqlBaseParserCURRENT_DATE          = 38
	SqlBaseParserCURRENT_PATH          = 39
	SqlBaseParserCURRENT_ROLE          = 40
	SqlBaseParserCURRENT_TIME          = 41
	SqlBaseParserCURRENT_TIMESTAMP     = 42
	SqlBaseParserCURRENT_USER          = 43
	SqlBaseParserDATA                  = 44
	SqlBaseParserDATE                  = 45
	SqlBaseParserDAY                   = 46
	SqlBaseParserDEALLOCATE            = 47
	SqlBaseParserDEFINER               = 48
	SqlBaseParserDELETE                = 49
	SqlBaseParserDESC                  = 50
	SqlBaseParserDESCRIBE              = 51
	SqlBaseParserDISTINCT              = 52
	SqlBaseParserDISTRIBUTED           = 53
	SqlBaseParserDOUBLE                = 54
	SqlBaseParserDROP                  = 55
	SqlBaseParserELSE                  = 56
	SqlBaseParserEND                   = 57
	SqlBaseParserESCAPE                = 58
	SqlBaseParserEXCEPT                = 59
	SqlBaseParserEXCLUDING             = 60
	SqlBaseParserEXECUTE               = 61
	SqlBaseParserEXISTS                = 62
	SqlBaseParserEXPLAIN               = 63
	SqlBaseParserEXTRACT               = 64
	SqlBaseParserFALSE                 = 65
	SqlBaseParserFETCH                 = 66
	SqlBaseParserFILTER                = 67
	SqlBaseParserFIRST                 = 68
	SqlBaseParserFOLLOWING             = 69
	SqlBaseParserFOR                   = 70
	SqlBaseParserFORMAT                = 71
	SqlBaseParserFROM                  = 72
	SqlBaseParserFULL                  = 73
	SqlBaseParserFUNCTIONS             = 74
	SqlBaseParserGRANT                 = 75
	SqlBaseParserGRANTED               = 76
	SqlBaseParserGRANTS                = 77
	SqlBaseParserGRAPHVIZ              = 78
	SqlBaseParserGROUP                 = 79
	SqlBaseParserGROUPING              = 80
	SqlBaseParserGROUPS                = 81
	SqlBaseParserHAVING                = 82
	SqlBaseParserHOUR                  = 83
	SqlBaseParserIF                    = 84
	SqlBaseParserIGNORE                = 85
	SqlBaseParserIN                    = 86
	SqlBaseParserINCLUDING             = 87
	SqlBaseParserINNER                 = 88
	SqlBaseParserINPUT                 = 89
	SqlBaseParserINSERT                = 90
	SqlBaseParserINTERSECT             = 91
	SqlBaseParserINTERVAL              = 92
	SqlBaseParserINTO                  = 93
	SqlBaseParserINVOKER               = 94
	SqlBaseParserIO                    = 95
	SqlBaseParserIS                    = 96
	SqlBaseParserISOLATION             = 97
	SqlBaseParserJOIN                  = 98
	SqlBaseParserJSON                  = 99
	SqlBaseParserLAST                  = 100
	SqlBaseParserLATERAL               = 101
	SqlBaseParserLEFT                  = 102
	SqlBaseParserLEVEL                 = 103
	SqlBaseParserLIKE                  = 104
	SqlBaseParserLIMIT                 = 105
	SqlBaseParserLOCALTIME             = 106
	SqlBaseParserLOCALTIMESTAMP        = 107
	SqlBaseParserLOGICAL               = 108
	SqlBaseParserMAP                   = 109
	SqlBaseParserMATERIALIZED          = 110
	SqlBaseParserMINUTE                = 111
	SqlBaseParserMONTH                 = 112
	SqlBaseParserNATURAL               = 113
	SqlBaseParserNEXT                  = 114
	SqlBaseParserNFC                   = 115
	SqlBaseParserNFD                   = 116
	SqlBaseParserNFKC                  = 117
	SqlBaseParserNFKD                  = 118
	SqlBaseParserNO                    = 119
	SqlBaseParserNONE                  = 120
	SqlBaseParserNORMALIZE             = 121
	SqlBaseParserNOT                   = 122
	SqlBaseParserNULL                  = 123
	SqlBaseParserNULLIF                = 124
	SqlBaseParserNULLS                 = 125
	SqlBaseParserOFFSET                = 126
	SqlBaseParserON                    = 127
	SqlBaseParserONLY                  = 128
	SqlBaseParserOPTION                = 129
	SqlBaseParserOR                    = 130
	SqlBaseParserORDER                 = 131
	SqlBaseParserORDINALITY            = 132
	SqlBaseParserOUTER                 = 133
	SqlBaseParserOUTPUT                = 134
	SqlBaseParserOVER                  = 135
	SqlBaseParserPARTITION             = 136
	SqlBaseParserPARTITIONS            = 137
	SqlBaseParserPATH                  = 138
	SqlBaseParserPOSITION              = 139
	SqlBaseParserPRECEDING             = 140
	SqlBaseParserPRECISION             = 141
	SqlBaseParserPREPARE               = 142
	SqlBaseParserPRIVILEGES            = 143
	SqlBaseParserPROPERTIES            = 144
	SqlBaseParserRANGE                 = 145
	SqlBaseParserREAD                  = 146
	SqlBaseParserRECURSIVE             = 147
	SqlBaseParserREFRESH               = 148
	SqlBaseParserRENAME                = 149
	SqlBaseParserREPEATABLE            = 150
	SqlBaseParserREPLACE               = 151
	SqlBaseParserRESET                 = 152
	SqlBaseParserRESPECT               = 153
	SqlBaseParserRESTRICT              = 154
	SqlBaseParserREVOKE                = 155
	SqlBaseParserRIGHT                 = 156
	SqlBaseParserROLE                  = 157
	SqlBaseParserROLES                 = 158
	SqlBaseParserROLLBACK              = 159
	SqlBaseParserROLLUP                = 160
	SqlBaseParserROW                   = 161
	SqlBaseParserROWS                  = 162
	SqlBaseParserSCHEMA                = 163
	SqlBaseParserSCHEMAS               = 164
	SqlBaseParserSECOND                = 165
	SqlBaseParserSECURITY              = 166
	SqlBaseParserSELECT                = 167
	SqlBaseParserSERIALIZABLE          = 168
	SqlBaseParserSESSION               = 169
	SqlBaseParserSET                   = 170
	SqlBaseParserSETS                  = 171
	SqlBaseParserSHOW                  = 172
	SqlBaseParserSOME                  = 173
	SqlBaseParserSTART                 = 174
	SqlBaseParserSTATS                 = 175
	SqlBaseParserSUBSTRING             = 176
	SqlBaseParserSYSTEM                = 177
	SqlBaseParserTABLE                 = 178
	SqlBaseParserTABLES                = 179
	SqlBaseParserTABLESAMPLE           = 180
	SqlBaseParserTEXT                  = 181
	SqlBaseParserTHEN                  = 182
	SqlBaseParserTIES                  = 183
	SqlBaseParserTIME                  = 184
	SqlBaseParserTIMESTAMP             = 185
	SqlBaseParserTO                    = 186
	SqlBaseParserTRANSACTION           = 187
	SqlBaseParserTRUE                  = 188
	SqlBaseParserTRY_CAST              = 189
	SqlBaseParserTYPE                  = 190
	SqlBaseParserUESCAPE               = 191
	SqlBaseParserUNBOUNDED             = 192
	SqlBaseParserUNCOMMITTED           = 193
	SqlBaseParserUNION                 = 194
	SqlBaseParserUNNEST                = 195
	SqlBaseParserUSE                   = 196
	SqlBaseParserUSER                  = 197
	SqlBaseParserUSING                 = 198
	SqlBaseParserVALIDATE              = 199
	SqlBaseParserVALUES                = 200
	SqlBaseParserVERBOSE               = 201
	SqlBaseParserVIEW                  = 202
	SqlBaseParserWHEN                  = 203
	SqlBaseParserWHERE                 = 204
	SqlBaseParserWITH                  = 205
	SqlBaseParserWITHOUT               = 206
	SqlBaseParserWORK                  = 207
	SqlBaseParserWRITE                 = 208
	SqlBaseParserYEAR                  = 209
	SqlBaseParserZONE                  = 210
	SqlBaseParserEQ                    = 211
	SqlBaseParserNEQ                   = 212
	SqlBaseParserLT                    = 213
	SqlBaseParserLTE                   = 214
	SqlBaseParserGT                    = 215
	SqlBaseParserGTE                   = 216
	SqlBaseParserPLUS                  = 217
	SqlBaseParserMINUS                 = 218
	SqlBaseParserASTERISK              = 219
	SqlBaseParserSLASH                 = 220
	SqlBaseParserPERCENT               = 221
	SqlBaseParserCONCAT                = 222
	SqlBaseParserSTRING                = 223
	SqlBaseParserUNICODE_STRING        = 224
	SqlBaseParserBINARY_LITERAL        = 225
	SqlBaseParserINTEGER_VALUE         = 226
	SqlBaseParserDECIMAL_VALUE         = 227
	SqlBaseParserDOUBLE_VALUE          = 228
	SqlBaseParserIDENTIFIER            = 229
	SqlBaseParserDIGIT_IDENTIFIER      = 230
	SqlBaseParserQUOTED_IDENTIFIER     = 231
	SqlBaseParserBACKQUOTED_IDENTIFIER = 232
	SqlBaseParserSIMPLE_COMMENT        = 233
	SqlBaseParserBRACKETED_COMMENT     = 234
	SqlBaseParserWS                    = 235
	SqlBaseParserPARAMETER             = 236
	SqlBaseParserUNRECOGNIZED          = 237
)

// SqlBaseParser rules.
const (
	SqlBaseParserRULE_statement            = 0
	SqlBaseParserRULE_query                = 1
	SqlBaseParserRULE_with                 = 2
	SqlBaseParserRULE_queryNoWith          = 3
	SqlBaseParserRULE_limitRowCount        = 4
	SqlBaseParserRULE_rowCount             = 5
	SqlBaseParserRULE_queryTerm            = 6
	SqlBaseParserRULE_queryPrimary         = 7
	SqlBaseParserRULE_sortItem             = 8
	SqlBaseParserRULE_querySpecification   = 9
	SqlBaseParserRULE_groupBy              = 10
	SqlBaseParserRULE_groupingElement      = 11
	SqlBaseParserRULE_groupingSet          = 12
	SqlBaseParserRULE_namedQuery           = 13
	SqlBaseParserRULE_setQuantifier        = 14
	SqlBaseParserRULE_selectItem           = 15
	SqlBaseParserRULE_relation             = 16
	SqlBaseParserRULE_joinType             = 17
	SqlBaseParserRULE_joinCriteria         = 18
	SqlBaseParserRULE_sampledRelation      = 19
	SqlBaseParserRULE_sampleType           = 20
	SqlBaseParserRULE_aliasedRelation      = 21
	SqlBaseParserRULE_columnAliases        = 22
	SqlBaseParserRULE_relationPrimary      = 23
	SqlBaseParserRULE_expression           = 24
	SqlBaseParserRULE_booleanExpression    = 25
	SqlBaseParserRULE_predicate            = 26
	SqlBaseParserRULE_valueExpression      = 27
	SqlBaseParserRULE_primaryExpression    = 28
	SqlBaseParserRULE_gstring              = 29
	SqlBaseParserRULE_timeZoneSpecifier    = 30
	SqlBaseParserRULE_comparisonOperator   = 31
	SqlBaseParserRULE_comparisonQuantifier = 32
	SqlBaseParserRULE_booleanValue         = 33
	SqlBaseParserRULE_interval             = 34
	SqlBaseParserRULE_intervalField        = 35
	SqlBaseParserRULE_normalForm           = 36
	SqlBaseParserRULE_gtype                = 37
	SqlBaseParserRULE_rowField             = 38
	SqlBaseParserRULE_typeParameter        = 39
	SqlBaseParserRULE_whenClause           = 40
	SqlBaseParserRULE_filter               = 41
	SqlBaseParserRULE_qualifiedName        = 42
	SqlBaseParserRULE_identifier           = 43
	SqlBaseParserRULE_number               = 44
	SqlBaseParserRULE_nonReserved          = 45
)

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ResetSessionContext struct {
	*StatementContext
}

func NewResetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResetSessionContext {
	var p = new(ResetSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ResetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSessionContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *ResetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *ResetSessionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterResetSession(s)
	}
}

func (s *ResetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitResetSession(s)
	}
}

func (s *ResetSessionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitResetSession(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCatalogsContext struct {
	*StatementContext
	pattern IGstringContext
	escape  IGstringContext
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCatalogsContext) GetPattern() IGstringContext { return s.pattern }

func (s *ShowCatalogsContext) GetEscape() IGstringContext { return s.escape }

func (s *ShowCatalogsContext) SetPattern(v IGstringContext) { s.pattern = v }

func (s *ShowCatalogsContext) SetEscape(v IGstringContext) { s.escape = v }

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCatalogsContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOGS, 0)
}

func (s *ShowCatalogsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowCatalogsContext) AllGstring() []IGstringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGstringContext)(nil)).Elem())
	var tst = make([]IGstringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGstringContext)
		}
	}

	return tst
}

func (s *ShowCatalogsContext) Gstring(i int) IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *ShowCatalogsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowCatalogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowCatalogs(s)

	default:
		return t.VisitChildren(s)
	}
}

type StatementDefaultContext struct {
	*StatementContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

func (s *StatementDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitStatementDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStatsContext struct {
	*StatementContext
}

func NewShowStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsContext {
	var p = new(ShowStatsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATS, 0)
}

func (s *ShowStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *ShowStatsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowStats(s)
	}
}

func (s *ShowStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowStats(s)
	}
}

func (s *ShowStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSessionContext struct {
	*StatementContext
	pattern IGstringContext
	escape  IGstringContext
}

func NewShowSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSessionContext {
	var p = new(ShowSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowSessionContext) GetPattern() IGstringContext { return s.pattern }

func (s *ShowSessionContext) GetEscape() IGstringContext { return s.escape }

func (s *ShowSessionContext) SetPattern(v IGstringContext) { s.pattern = v }

func (s *ShowSessionContext) SetEscape(v IGstringContext) { s.escape = v }

func (s *ShowSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSessionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *ShowSessionContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowSessionContext) AllGstring() []IGstringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGstringContext)(nil)).Elem())
	var tst = make([]IGstringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGstringContext)
		}
	}

	return tst
}

func (s *ShowSessionContext) Gstring(i int) IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *ShowSessionContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowSession(s)
	}
}

func (s *ShowSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowSession(s)
	}
}

func (s *ShowSessionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowSession(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowFunctionsContext struct {
	*StatementContext
	pattern IGstringContext
	escape  IGstringContext
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowFunctionsContext) GetPattern() IGstringContext { return s.pattern }

func (s *ShowFunctionsContext) GetEscape() IGstringContext { return s.escape }

func (s *ShowFunctionsContext) SetPattern(v IGstringContext) { s.pattern = v }

func (s *ShowFunctionsContext) SetEscape(v IGstringContext) { s.escape = v }

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *ShowFunctionsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowFunctionsContext) AllGstring() []IGstringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGstringContext)(nil)).Elem())
	var tst = make([]IGstringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGstringContext)
		}
	}

	return tst
}

func (s *ShowFunctionsContext) Gstring(i int) IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *ShowFunctionsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowFunctions(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetSessionContext struct {
	*StatementContext
}

func NewSetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSessionContext {
	var p = new(SetSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSessionContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *SetSessionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetSessionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *SetSessionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetSession(s)
	}
}

func (s *SetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetSession(s)
	}
}

func (s *SetSessionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSetSession(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTablesContext struct {
	*StatementContext
	pattern IGstringContext
	escape  IGstringContext
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowTablesContext) GetPattern() IGstringContext { return s.pattern }

func (s *ShowTablesContext) GetEscape() IGstringContext { return s.escape }

func (s *ShowTablesContext) SetPattern(v IGstringContext) { s.pattern = v }

func (s *ShowTablesContext) SetEscape(v IGstringContext) { s.escape = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *ShowTablesContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTablesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowTablesContext) AllGstring() []IGstringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGstringContext)(nil)).Elem())
	var tst = make([]IGstringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGstringContext)
		}
	}

	return tst
}

func (s *ShowTablesContext) Gstring(i int) IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *ShowTablesContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowTables(s)
	}
}

func (s *ShowTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowTables(s)
	}
}

func (s *ShowTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowTables(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSchemasContext struct {
	*StatementContext
	pattern IGstringContext
	escape  IGstringContext
}

func NewShowSchemasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemasContext {
	var p = new(ShowSchemasContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowSchemasContext) GetPattern() IGstringContext { return s.pattern }

func (s *ShowSchemasContext) GetEscape() IGstringContext { return s.escape }

func (s *ShowSchemasContext) SetPattern(v IGstringContext) { s.pattern = v }

func (s *ShowSchemasContext) SetEscape(v IGstringContext) { s.escape = v }

func (s *ShowSchemasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemasContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowSchemasContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMAS, 0)
}

func (s *ShowSchemasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSchemasContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowSchemasContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowSchemasContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowSchemasContext) AllGstring() []IGstringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGstringContext)(nil)).Elem())
	var tst = make([]IGstringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGstringContext)
		}
	}

	return tst
}

func (s *ShowSchemasContext) Gstring(i int) IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *ShowSchemasContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowSchemasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowSchemas(s)
	}
}

func (s *ShowSchemasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowSchemas(s)
	}
}

func (s *ShowSchemasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowSchemas(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowColumnsContext struct {
	*StatementContext
	pattern IGstringContext
	escape  IGstringContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetPattern() IGstringContext { return s.pattern }

func (s *ShowColumnsContext) GetEscape() IGstringContext { return s.escape }

func (s *ShowColumnsContext) SetPattern(v IGstringContext) { s.pattern = v }

func (s *ShowColumnsContext) SetEscape(v IGstringContext) { s.escape = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowColumnsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowColumnsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowColumnsContext) AllGstring() []IGstringContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGstringContext)(nil)).Elem())
	var tst = make([]IGstringContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGstringContext)
		}
	}

	return tst
}

func (s *ShowColumnsContext) Gstring(i int) IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *ShowColumnsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowColumnsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *ShowColumnsContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

func (s *ShowColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStatsForQueryContext struct {
	*StatementContext
}

func NewShowStatsForQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsForQueryContext {
	var p = new(ShowStatsForQueryContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsForQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsForQueryContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowStatsForQueryContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATS, 0)
}

func (s *ShowStatsForQueryContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *ShowStatsForQueryContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *ShowStatsForQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowStatsForQuery(s)
	}
}

func (s *ShowStatsForQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowStatsForQuery(s)
	}
}

func (s *ShowStatsForQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowStatsForQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SqlBaseParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(189)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(92)
			p.Query()
		}

	case 2:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(93)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(94)
			p.Match(SqlBaseParserTABLES)
		}
		p.SetState(97)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(95)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(96)
				p.QualifiedName()
			}

		}
		p.SetState(105)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(99)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(100)

				var _x = p.Gstring()

				localctx.(*ShowTablesContext).pattern = _x
			}
			p.SetState(103)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(101)
					p.Match(SqlBaseParserESCAPE)
				}
				{
					p.SetState(102)

					var _x = p.Gstring()

					localctx.(*ShowTablesContext).escape = _x
				}

			}

		}

	case 3:
		localctx = NewShowSchemasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(107)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(108)
			p.Match(SqlBaseParserSCHEMAS)
		}
		p.SetState(111)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(109)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(110)
				p.Identifier()
			}

		}
		p.SetState(119)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(113)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(114)

				var _x = p.Gstring()

				localctx.(*ShowSchemasContext).pattern = _x
			}
			p.SetState(117)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(115)
					p.Match(SqlBaseParserESCAPE)
				}
				{
					p.SetState(116)

					var _x = p.Gstring()

					localctx.(*ShowSchemasContext).escape = _x
				}

			}

		}

	case 4:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(121)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(122)
			p.Match(SqlBaseParserCATALOGS)
		}
		p.SetState(129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(123)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(124)

				var _x = p.Gstring()

				localctx.(*ShowCatalogsContext).pattern = _x
			}
			p.SetState(127)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(125)
					p.Match(SqlBaseParserESCAPE)
				}
				{
					p.SetState(126)

					var _x = p.Gstring()

					localctx.(*ShowCatalogsContext).escape = _x
				}

			}

		}

	case 5:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(131)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(132)
			p.Match(SqlBaseParserCOLUMNS)
		}
		{
			p.SetState(133)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(135)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-8)&-(0x1f+1)) == 0 && ((1<<uint((_la-8)))&((1<<(SqlBaseParserADD-8))|(1<<(SqlBaseParserADMIN-8))|(1<<(SqlBaseParserALL-8))|(1<<(SqlBaseParserANALYZE-8))|(1<<(SqlBaseParserANY-8))|(1<<(SqlBaseParserARRAY-8))|(1<<(SqlBaseParserASC-8))|(1<<(SqlBaseParserAT-8))|(1<<(SqlBaseParserAUTHORIZATION-8))|(1<<(SqlBaseParserBERNOULLI-8))|(1<<(SqlBaseParserCALL-8))|(1<<(SqlBaseParserCASCADE-8))|(1<<(SqlBaseParserCATALOGS-8))|(1<<(SqlBaseParserCOLUMN-8))|(1<<(SqlBaseParserCOLUMNS-8))|(1<<(SqlBaseParserCOMMENT-8))|(1<<(SqlBaseParserCOMMIT-8))|(1<<(SqlBaseParserCOMMITTED-8))|(1<<(SqlBaseParserCURRENT-8)))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SqlBaseParserDATA-44))|(1<<(SqlBaseParserDATE-44))|(1<<(SqlBaseParserDAY-44))|(1<<(SqlBaseParserDEFINER-44))|(1<<(SqlBaseParserDESC-44))|(1<<(SqlBaseParserDISTRIBUTED-44))|(1<<(SqlBaseParserDOUBLE-44))|(1<<(SqlBaseParserEXCLUDING-44))|(1<<(SqlBaseParserEXPLAIN-44))|(1<<(SqlBaseParserFETCH-44))|(1<<(SqlBaseParserFILTER-44))|(1<<(SqlBaseParserFIRST-44))|(1<<(SqlBaseParserFOLLOWING-44))|(1<<(SqlBaseParserFORMAT-44))|(1<<(SqlBaseParserFUNCTIONS-44))|(1<<(SqlBaseParserGRANT-44)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(SqlBaseParserGRANTED-76))|(1<<(SqlBaseParserGRANTS-76))|(1<<(SqlBaseParserGRAPHVIZ-76))|(1<<(SqlBaseParserGROUPS-76))|(1<<(SqlBaseParserHOUR-76))|(1<<(SqlBaseParserIF-76))|(1<<(SqlBaseParserIGNORE-76))|(1<<(SqlBaseParserINCLUDING-76))|(1<<(SqlBaseParserINPUT-76))|(1<<(SqlBaseParserINTERVAL-76))|(1<<(SqlBaseParserINVOKER-76))|(1<<(SqlBaseParserIO-76))|(1<<(SqlBaseParserISOLATION-76))|(1<<(SqlBaseParserJSON-76))|(1<<(SqlBaseParserLAST-76))|(1<<(SqlBaseParserLATERAL-76))|(1<<(SqlBaseParserLEVEL-76))|(1<<(SqlBaseParserLIMIT-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(SqlBaseParserLOGICAL-108))|(1<<(SqlBaseParserMAP-108))|(1<<(SqlBaseParserMATERIALIZED-108))|(1<<(SqlBaseParserMINUTE-108))|(1<<(SqlBaseParserMONTH-108))|(1<<(SqlBaseParserNEXT-108))|(1<<(SqlBaseParserNFC-108))|(1<<(SqlBaseParserNFD-108))|(1<<(SqlBaseParserNFKC-108))|(1<<(SqlBaseParserNFKD-108))|(1<<(SqlBaseParserNO-108))|(1<<(SqlBaseParserNONE-108))|(1<<(SqlBaseParserNULLIF-108))|(1<<(SqlBaseParserNULLS-108))|(1<<(SqlBaseParserOFFSET-108))|(1<<(SqlBaseParserONLY-108))|(1<<(SqlBaseParserOPTION-108))|(1<<(SqlBaseParserORDINALITY-108))|(1<<(SqlBaseParserOUTPUT-108))|(1<<(SqlBaseParserOVER-108))|(1<<(SqlBaseParserPARTITION-108))|(1<<(SqlBaseParserPARTITIONS-108))|(1<<(SqlBaseParserPATH-108))|(1<<(SqlBaseParserPOSITION-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(SqlBaseParserPRECEDING-140))|(1<<(SqlBaseParserPRECISION-140))|(1<<(SqlBaseParserPRIVILEGES-140))|(1<<(SqlBaseParserPROPERTIES-140))|(1<<(SqlBaseParserRANGE-140))|(1<<(SqlBaseParserREAD-140))|(1<<(SqlBaseParserREFRESH-140))|(1<<(SqlBaseParserRENAME-140))|(1<<(SqlBaseParserREPEATABLE-140))|(1<<(SqlBaseParserREPLACE-140))|(1<<(SqlBaseParserRESET-140))|(1<<(SqlBaseParserRESPECT-140))|(1<<(SqlBaseParserRESTRICT-140))|(1<<(SqlBaseParserREVOKE-140))|(1<<(SqlBaseParserROLE-140))|(1<<(SqlBaseParserROLES-140))|(1<<(SqlBaseParserROLLBACK-140))|(1<<(SqlBaseParserROW-140))|(1<<(SqlBaseParserROWS-140))|(1<<(SqlBaseParserSCHEMA-140))|(1<<(SqlBaseParserSCHEMAS-140))|(1<<(SqlBaseParserSECOND-140))|(1<<(SqlBaseParserSECURITY-140))|(1<<(SqlBaseParserSERIALIZABLE-140))|(1<<(SqlBaseParserSESSION-140))|(1<<(SqlBaseParserSET-140))|(1<<(SqlBaseParserSETS-140)))) != 0) || (((_la-172)&-(0x1f+1)) == 0 && ((1<<uint((_la-172)))&((1<<(SqlBaseParserSHOW-172))|(1<<(SqlBaseParserSOME-172))|(1<<(SqlBaseParserSTART-172))|(1<<(SqlBaseParserSTATS-172))|(1<<(SqlBaseParserSUBSTRING-172))|(1<<(SqlBaseParserSYSTEM-172))|(1<<(SqlBaseParserTABLES-172))|(1<<(SqlBaseParserTABLESAMPLE-172))|(1<<(SqlBaseParserTEXT-172))|(1<<(SqlBaseParserTIES-172))|(1<<(SqlBaseParserTIME-172))|(1<<(SqlBaseParserTIMESTAMP-172))|(1<<(SqlBaseParserTO-172))|(1<<(SqlBaseParserTRANSACTION-172))|(1<<(SqlBaseParserTRY_CAST-172))|(1<<(SqlBaseParserTYPE-172))|(1<<(SqlBaseParserUNBOUNDED-172))|(1<<(SqlBaseParserUNCOMMITTED-172))|(1<<(SqlBaseParserUSE-172))|(1<<(SqlBaseParserUSER-172))|(1<<(SqlBaseParserVALIDATE-172))|(1<<(SqlBaseParserVERBOSE-172))|(1<<(SqlBaseParserVIEW-172)))) != 0) || (((_la-206)&-(0x1f+1)) == 0 && ((1<<uint((_la-206)))&((1<<(SqlBaseParserWITHOUT-206))|(1<<(SqlBaseParserWORK-206))|(1<<(SqlBaseParserWRITE-206))|(1<<(SqlBaseParserYEAR-206))|(1<<(SqlBaseParserZONE-206))|(1<<(SqlBaseParserIDENTIFIER-206))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-206))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-206))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-206)))) != 0) {
			{
				p.SetState(134)
				p.QualifiedName()
			}

		}
		p.SetState(143)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(137)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(138)

				var _x = p.Gstring()

				localctx.(*ShowColumnsContext).pattern = _x
			}
			p.SetState(141)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(139)
					p.Match(SqlBaseParserESCAPE)
				}
				{
					p.SetState(140)

					var _x = p.Gstring()

					localctx.(*ShowColumnsContext).escape = _x
				}

			}

		}

	case 6:
		localctx = NewShowStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(145)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(146)
			p.Match(SqlBaseParserSTATS)
		}
		{
			p.SetState(147)
			p.Match(SqlBaseParserFOR)
		}
		{
			p.SetState(148)
			p.QualifiedName()
		}

	case 7:
		localctx = NewShowStatsForQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(149)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(150)
			p.Match(SqlBaseParserSTATS)
		}
		{
			p.SetState(151)
			p.Match(SqlBaseParserFOR)
		}
		{
			p.SetState(152)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(153)
			p.QuerySpecification()
		}
		{
			p.SetState(154)
			p.Match(SqlBaseParserT__1)
		}

	case 8:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(156)
			p.Match(SqlBaseParserDESCRIBE)
		}
		{
			p.SetState(157)
			p.QualifiedName()
		}

	case 9:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(158)
			p.Match(SqlBaseParserDESC)
		}
		{
			p.SetState(159)
			p.QualifiedName()
		}

	case 10:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(160)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(161)
			p.Match(SqlBaseParserFUNCTIONS)
		}
		p.SetState(168)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(162)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(163)

				var _x = p.Gstring()

				localctx.(*ShowFunctionsContext).pattern = _x
			}
			p.SetState(166)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(164)
					p.Match(SqlBaseParserESCAPE)
				}
				{
					p.SetState(165)

					var _x = p.Gstring()

					localctx.(*ShowFunctionsContext).escape = _x
				}

			}

		}

	case 11:
		localctx = NewShowSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(170)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(171)
			p.Match(SqlBaseParserSESSION)
		}
		p.SetState(178)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(172)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(173)

				var _x = p.Gstring()

				localctx.(*ShowSessionContext).pattern = _x
			}
			p.SetState(176)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(174)
					p.Match(SqlBaseParserESCAPE)
				}
				{
					p.SetState(175)

					var _x = p.Gstring()

					localctx.(*ShowSessionContext).escape = _x
				}

			}

		}

	case 12:
		localctx = NewSetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(180)
			p.Match(SqlBaseParserSET)
		}
		{
			p.SetState(181)
			p.Match(SqlBaseParserSESSION)
		}
		{
			p.SetState(182)
			p.QualifiedName()
		}
		{
			p.SetState(183)
			p.Match(SqlBaseParserEQ)
		}
		{
			p.SetState(184)
			p.Expression()
		}

	case 13:
		localctx = NewResetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(186)
			p.Match(SqlBaseParserRESET)
		}
		{
			p.SetState(187)
			p.Match(SqlBaseParserSESSION)
		}
		{
			p.SetState(188)
			p.QualifiedName()
		}

	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryNoWith() IQueryNoWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryNoWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryContext) With() IWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SqlBaseParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserWITH {
		{
			p.SetState(191)
			p.With()
		}

	}
	{
		p.SetState(194)
		p.QueryNoWith()
	}

	return localctx
}

// IWithContext is an interface to support dynamic dispatch.
type IWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithContext differentiates from other interfaces.
	IsWithContext()
}

type WithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithContext() *WithContext {
	var p = new(WithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_with
	return p
}

func (*WithContext) IsWithContext() {}

func NewWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithContext {
	var p = new(WithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_with

	return p
}

func (s *WithContext) GetParser() antlr.Parser { return s.parser }

func (s *WithContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *WithContext) AllNamedQuery() []INamedQueryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedQueryContext)(nil)).Elem())
	var tst = make([]INamedQueryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedQueryContext)
		}
	}

	return tst
}

func (s *WithContext) NamedQuery(i int) INamedQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedQueryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *WithContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECURSIVE, 0)
}

func (s *WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWith(s)
	}
}

func (s *WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWith(s)
	}
}

func (s *WithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) With() (localctx IWithContext) {
	localctx = NewWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SqlBaseParserRULE_with)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(196)
		p.Match(SqlBaseParserWITH)
	}
	p.SetState(198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserRECURSIVE {
		{
			p.SetState(197)
			p.Match(SqlBaseParserRECURSIVE)
		}

	}
	{
		p.SetState(200)
		p.NamedQuery()
	}
	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__2 {
		{
			p.SetState(201)
			p.Match(SqlBaseParserT__2)
		}
		{
			p.SetState(202)
			p.NamedQuery()
		}

		p.SetState(207)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() IRowCountContext

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitRowCountContext

	// GetFetchFirst returns the fetchFirst rule contexts.
	GetFetchFirst() IRowCountContext

	// SetOffset sets the offset rule contexts.
	SetOffset(IRowCountContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitRowCountContext)

	// SetFetchFirst sets the fetchFirst rule contexts.
	SetFetchFirst(IRowCountContext)

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	offset     IRowCountContext
	limit      ILimitRowCountContext
	fetchFirst IRowCountContext
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryNoWith
	return p
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) GetOffset() IRowCountContext { return s.offset }

func (s *QueryNoWithContext) GetLimit() ILimitRowCountContext { return s.limit }

func (s *QueryNoWithContext) GetFetchFirst() IRowCountContext { return s.fetchFirst }

func (s *QueryNoWithContext) SetOffset(v IRowCountContext) { s.offset = v }

func (s *QueryNoWithContext) SetLimit(v ILimitRowCountContext) { s.limit = v }

func (s *QueryNoWithContext) SetFetchFirst(v IRowCountContext) { s.fetchFirst = v }

func (s *QueryNoWithContext) QueryTerm() IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryNoWithContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *QueryNoWithContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOFFSET, 0)
}

func (s *QueryNoWithContext) AllRowCount() []IRowCountContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRowCountContext)(nil)).Elem())
	var tst = make([]IRowCountContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRowCountContext)
		}
	}

	return tst
}

func (s *QueryNoWithContext) RowCount(i int) IRowCountContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRowCountContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRowCountContext)
}

func (s *QueryNoWithContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *QueryNoWithContext) FETCH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFETCH, 0)
}

func (s *QueryNoWithContext) LimitRowCount() ILimitRowCountContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitRowCountContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitRowCountContext)
}

func (s *QueryNoWithContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *QueryNoWithContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEXT, 0)
}

func (s *QueryNoWithContext) AllROW() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserROW)
}

func (s *QueryNoWithContext) ROW(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, i)
}

func (s *QueryNoWithContext) AllROWS() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserROWS)
}

func (s *QueryNoWithContext) ROWS(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, i)
}

func (s *QueryNoWithContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserONLY, 0)
}

func (s *QueryNoWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *QueryNoWithContext) TIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIES, 0)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQueryNoWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SqlBaseParserRULE_queryNoWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(208)
		p.queryTerm(0)
	}
	p.SetState(219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserORDER {
		{
			p.SetState(209)
			p.Match(SqlBaseParserORDER)
		}
		{
			p.SetState(210)
			p.Match(SqlBaseParserBY)
		}
		{
			p.SetState(211)
			p.SortItem()
		}
		p.SetState(216)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__2 {
			{
				p.SetState(212)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(213)
				p.SortItem()
			}

			p.SetState(218)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserOFFSET {
		{
			p.SetState(221)
			p.Match(SqlBaseParserOFFSET)
		}
		{
			p.SetState(222)

			var _x = p.RowCount()

			localctx.(*QueryNoWithContext).offset = _x
		}
		p.SetState(224)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserROW || _la == SqlBaseParserROWS {
			{
				p.SetState(223)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserROW || _la == SqlBaseParserROWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}
	p.SetState(241)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserLIMIT:
		{
			p.SetState(228)
			p.Match(SqlBaseParserLIMIT)
		}
		{
			p.SetState(229)

			var _x = p.LimitRowCount()

			localctx.(*QueryNoWithContext).limit = _x
		}

	case SqlBaseParserFETCH:
		{
			p.SetState(230)
			p.Match(SqlBaseParserFETCH)
		}
		{
			p.SetState(231)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFIRST || _la == SqlBaseParserNEXT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserINTEGER_VALUE || _la == SqlBaseParserPARAMETER {
			{
				p.SetState(232)

				var _x = p.RowCount()

				localctx.(*QueryNoWithContext).fetchFirst = _x
			}

		}
		{
			p.SetState(235)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserROW || _la == SqlBaseParserROWS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(239)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SqlBaseParserONLY:
			{
				p.SetState(236)
				p.Match(SqlBaseParserONLY)
			}

		case SqlBaseParserWITH:
			{
				p.SetState(237)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(238)
				p.Match(SqlBaseParserTIES)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case SqlBaseParserEOF, SqlBaseParserT__1:

	default:
	}

	return localctx
}

// ILimitRowCountContext is an interface to support dynamic dispatch.
type ILimitRowCountContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitRowCountContext differentiates from other interfaces.
	IsLimitRowCountContext()
}

type LimitRowCountContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitRowCountContext() *LimitRowCountContext {
	var p = new(LimitRowCountContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_limitRowCount
	return p
}

func (*LimitRowCountContext) IsLimitRowCountContext() {}

func NewLimitRowCountContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitRowCountContext {
	var p = new(LimitRowCountContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_limitRowCount

	return p
}

func (s *LimitRowCountContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitRowCountContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *LimitRowCountContext) RowCount() IRowCountContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRowCountContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRowCountContext)
}

func (s *LimitRowCountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitRowCountContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitRowCountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLimitRowCount(s)
	}
}

func (s *LimitRowCountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLimitRowCount(s)
	}
}

func (s *LimitRowCountContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLimitRowCount(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) LimitRowCount() (localctx ILimitRowCountContext) {
	localctx = NewLimitRowCountContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SqlBaseParserRULE_limitRowCount)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(245)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(243)
			p.Match(SqlBaseParserALL)
		}

	case SqlBaseParserINTEGER_VALUE, SqlBaseParserPARAMETER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(244)
			p.RowCount()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRowCountContext is an interface to support dynamic dispatch.
type IRowCountContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRowCountContext differentiates from other interfaces.
	IsRowCountContext()
}

type RowCountContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowCountContext() *RowCountContext {
	var p = new(RowCountContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_rowCount
	return p
}

func (*RowCountContext) IsRowCountContext() {}

func NewRowCountContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowCountContext {
	var p = new(RowCountContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_rowCount

	return p
}

func (s *RowCountContext) GetParser() antlr.Parser { return s.parser }

func (s *RowCountContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *RowCountContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARAMETER, 0)
}

func (s *RowCountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowCountContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowCountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRowCount(s)
	}
}

func (s *RowCountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRowCount(s)
	}
}

func (s *RowCountContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRowCount(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) RowCount() (localctx IRowCountContext) {
	localctx = NewRowCountContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SqlBaseParserRULE_rowCount)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(247)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserINTEGER_VALUE || _la == SqlBaseParserPARAMETER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryTerm
	return p
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyFrom(ctx *QueryTermContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	*QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQueryTermDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetOperationContext struct {
	*QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQueryTermContext)(nil)).Elem())
	var tst = make([]IQueryTermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQueryTermContext)
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCEPT, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (s *SetOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSetOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *SqlBaseParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 12
	p.EnterRecursionRule(localctx, 12, SqlBaseParserRULE_queryTerm, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(250)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(266)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(264)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(252)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(253)

					var _m = p.Match(SqlBaseParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
				}
				p.SetState(255)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
					{
						p.SetState(254)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(257)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(258)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(259)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserEXCEPT || _la == SqlBaseParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(261)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
					{
						p.SetState(260)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(263)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			}

		}
		p.SetState(268)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}

	return localctx
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryPrimary
	return p
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyFrom(ctx *QueryPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	*QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) QueryNoWith() IQueryNoWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryNoWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryPrimaryDefaultContext struct {
	*QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQueryPrimaryDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableContext struct {
	*QueryPrimaryContext
}

func NewTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableContext {
	var p = new(TableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *TableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTable(s)
	}
}

func (s *TableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type InlineTableContext struct {
	*QueryPrimaryContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, 0)
}

func (s *InlineTableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InlineTableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (s *InlineTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitInlineTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SqlBaseParserRULE_queryPrimary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(285)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(269)
			p.QuerySpecification()
		}

	case SqlBaseParserTABLE:
		localctx = NewTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(270)
			p.Match(SqlBaseParserTABLE)
		}
		{
			p.SetState(271)
			p.QualifiedName()
		}

	case SqlBaseParserVALUES:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(272)
			p.Match(SqlBaseParserVALUES)
		}
		{
			p.SetState(273)
			p.Expression()
		}
		p.SetState(278)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(274)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(275)
					p.Expression()
				}

			}
			p.SetState(280)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
		}

	case SqlBaseParserT__0:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(281)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(282)
			p.QueryNoWith()
		}
		{
			p.SetState(283)
			p.Match(SqlBaseParserT__1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sortItem
	return p
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SqlBaseParserRULE_sortItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Expression()
	}
	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserASC || _la == SqlBaseParserDESC {
		{
			p.SetState(288)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserASC || _la == SqlBaseParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserNULLS {
		{
			p.SetState(291)
			p.Match(SqlBaseParserNULLS)
		}
		{
			p.SetState(292)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFIRST || _la == SqlBaseParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_querySpecification
	return p
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QuerySpecificationContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectItemContext)(nil)).Elem())
	var tst = make([]ISelectItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectItemContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *QuerySpecificationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *QuerySpecificationContext) GroupBy() IGroupByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHAVING, 0)
}

func (s *QuerySpecificationContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SqlBaseParserRULE_querySpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		p.Match(SqlBaseParserSELECT)
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(296)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(299)
		p.SelectItem()
	}
	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(300)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(301)
				p.SelectItem()
			}

		}
		p.SetState(306)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
	}
	p.SetState(316)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(307)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(308)
			p.relation(0)
		}
		p.SetState(313)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(309)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(310)
					p.relation(0)
				}

			}
			p.SetState(315)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
		}

	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(318)
			p.Match(SqlBaseParserWHERE)
		}
		{
			p.SetState(319)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	}
	p.SetState(325)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(322)
			p.Match(SqlBaseParserGROUP)
		}
		{
			p.SetState(323)
			p.Match(SqlBaseParserBY)
		}
		{
			p.SetState(324)
			p.GroupBy()
		}

	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(327)
			p.Match(SqlBaseParserHAVING)
		}
		{
			p.SetState(328)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	}

	return localctx
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupBy
	return p
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllGroupingElement() []IGroupingElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem())
	var tst = make([]IGroupingElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupingElementContext)
		}
	}

	return tst
}

func (s *GroupByContext) GroupingElement(i int) IGroupingElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupByContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (s *GroupByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitGroupBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SqlBaseParserRULE_groupBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(332)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(331)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(334)
		p.GroupingElement()
	}
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(335)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(336)
				p.GroupingElement()
			}

		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingElement
	return p
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyFrom(ctx *GroupingElementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	*GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *MultipleGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem())
	var tst = make([]IGroupingSetContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupingSetContext)
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitMultipleGroupingSets(s)

	default:
		return t.VisitChildren(s)
	}
}

type SingleGroupingSetContext struct {
	*GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) GroupingSet() IGroupingSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSingleGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

type CubeContext struct {
	*GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *CubeContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *CubeContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCube(s)
	}
}

func (s *CubeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCube(s)

	default:
		return t.VisitChildren(s)
	}
}

type RollupContext struct {
	*GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLUP, 0)
}

func (s *RollupContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RollupContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (s *RollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SqlBaseParserRULE_groupingElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(342)
			p.GroupingSet()
		}

	case 2:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(343)
			p.Match(SqlBaseParserROLLUP)
		}
		{
			p.SetState(344)
			p.Match(SqlBaseParserT__0)
		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__0)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserAUTHORIZATION)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS)|(1<<SqlBaseParserCOMMENT)|(1<<SqlBaseParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_PATH-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserDOUBLE-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32))|(1<<(SqlBaseParserEXPLAIN-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFETCH-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserGROUPS-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64))|(1<<(SqlBaseParserIO-64)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlBaseParserISOLATION-97))|(1<<(SqlBaseParserJSON-97))|(1<<(SqlBaseParserLAST-97))|(1<<(SqlBaseParserLATERAL-97))|(1<<(SqlBaseParserLEVEL-97))|(1<<(SqlBaseParserLIMIT-97))|(1<<(SqlBaseParserLOCALTIME-97))|(1<<(SqlBaseParserLOCALTIMESTAMP-97))|(1<<(SqlBaseParserLOGICAL-97))|(1<<(SqlBaseParserMAP-97))|(1<<(SqlBaseParserMATERIALIZED-97))|(1<<(SqlBaseParserMINUTE-97))|(1<<(SqlBaseParserMONTH-97))|(1<<(SqlBaseParserNEXT-97))|(1<<(SqlBaseParserNFC-97))|(1<<(SqlBaseParserNFD-97))|(1<<(SqlBaseParserNFKC-97))|(1<<(SqlBaseParserNFKD-97))|(1<<(SqlBaseParserNO-97))|(1<<(SqlBaseParserNONE-97))|(1<<(SqlBaseParserNORMALIZE-97))|(1<<(SqlBaseParserNOT-97))|(1<<(SqlBaseParserNULL-97))|(1<<(SqlBaseParserNULLIF-97))|(1<<(SqlBaseParserNULLS-97))|(1<<(SqlBaseParserOFFSET-97))|(1<<(SqlBaseParserONLY-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBaseParserOPTION-129))|(1<<(SqlBaseParserORDINALITY-129))|(1<<(SqlBaseParserOUTPUT-129))|(1<<(SqlBaseParserOVER-129))|(1<<(SqlBaseParserPARTITION-129))|(1<<(SqlBaseParserPARTITIONS-129))|(1<<(SqlBaseParserPATH-129))|(1<<(SqlBaseParserPOSITION-129))|(1<<(SqlBaseParserPRECEDING-129))|(1<<(SqlBaseParserPRECISION-129))|(1<<(SqlBaseParserPRIVILEGES-129))|(1<<(SqlBaseParserPROPERTIES-129))|(1<<(SqlBaseParserRANGE-129))|(1<<(SqlBaseParserREAD-129))|(1<<(SqlBaseParserREFRESH-129))|(1<<(SqlBaseParserRENAME-129))|(1<<(SqlBaseParserREPEATABLE-129))|(1<<(SqlBaseParserREPLACE-129))|(1<<(SqlBaseParserRESET-129))|(1<<(SqlBaseParserRESPECT-129))|(1<<(SqlBaseParserRESTRICT-129))|(1<<(SqlBaseParserREVOKE-129))|(1<<(SqlBaseParserROLE-129))|(1<<(SqlBaseParserROLES-129))|(1<<(SqlBaseParserROLLBACK-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBaseParserROW-161))|(1<<(SqlBaseParserROWS-161))|(1<<(SqlBaseParserSCHEMA-161))|(1<<(SqlBaseParserSCHEMAS-161))|(1<<(SqlBaseParserSECOND-161))|(1<<(SqlBaseParserSECURITY-161))|(1<<(SqlBaseParserSERIALIZABLE-161))|(1<<(SqlBaseParserSESSION-161))|(1<<(SqlBaseParserSET-161))|(1<<(SqlBaseParserSETS-161))|(1<<(SqlBaseParserSHOW-161))|(1<<(SqlBaseParserSOME-161))|(1<<(SqlBaseParserSTART-161))|(1<<(SqlBaseParserSTATS-161))|(1<<(SqlBaseParserSUBSTRING-161))|(1<<(SqlBaseParserSYSTEM-161))|(1<<(SqlBaseParserTABLES-161))|(1<<(SqlBaseParserTABLESAMPLE-161))|(1<<(SqlBaseParserTEXT-161))|(1<<(SqlBaseParserTIES-161))|(1<<(SqlBaseParserTIME-161))|(1<<(SqlBaseParserTIMESTAMP-161))|(1<<(SqlBaseParserTO-161))|(1<<(SqlBaseParserTRANSACTION-161))|(1<<(SqlBaseParserTRUE-161))|(1<<(SqlBaseParserTRY_CAST-161))|(1<<(SqlBaseParserTYPE-161))|(1<<(SqlBaseParserUNBOUNDED-161)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(SqlBaseParserUNCOMMITTED-193))|(1<<(SqlBaseParserUSE-193))|(1<<(SqlBaseParserUSER-193))|(1<<(SqlBaseParserVALIDATE-193))|(1<<(SqlBaseParserVERBOSE-193))|(1<<(SqlBaseParserVIEW-193))|(1<<(SqlBaseParserWITHOUT-193))|(1<<(SqlBaseParserWORK-193))|(1<<(SqlBaseParserWRITE-193))|(1<<(SqlBaseParserYEAR-193))|(1<<(SqlBaseParserZONE-193))|(1<<(SqlBaseParserPLUS-193))|(1<<(SqlBaseParserMINUS-193))|(1<<(SqlBaseParserSTRING-193))|(1<<(SqlBaseParserUNICODE_STRING-193)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserPARAMETER-225)))) != 0) {
			{
				p.SetState(345)
				p.Expression()
			}
			p.SetState(350)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__2 {
				{
					p.SetState(346)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(347)
					p.Expression()
				}

				p.SetState(352)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(355)
			p.Match(SqlBaseParserT__1)
		}

	case 3:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(356)
			p.Match(SqlBaseParserCUBE)
		}
		{
			p.SetState(357)
			p.Match(SqlBaseParserT__0)
		}
		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__0)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserAUTHORIZATION)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS)|(1<<SqlBaseParserCOMMENT)|(1<<SqlBaseParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_PATH-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserDOUBLE-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32))|(1<<(SqlBaseParserEXPLAIN-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFETCH-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserGROUPS-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64))|(1<<(SqlBaseParserIO-64)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlBaseParserISOLATION-97))|(1<<(SqlBaseParserJSON-97))|(1<<(SqlBaseParserLAST-97))|(1<<(SqlBaseParserLATERAL-97))|(1<<(SqlBaseParserLEVEL-97))|(1<<(SqlBaseParserLIMIT-97))|(1<<(SqlBaseParserLOCALTIME-97))|(1<<(SqlBaseParserLOCALTIMESTAMP-97))|(1<<(SqlBaseParserLOGICAL-97))|(1<<(SqlBaseParserMAP-97))|(1<<(SqlBaseParserMATERIALIZED-97))|(1<<(SqlBaseParserMINUTE-97))|(1<<(SqlBaseParserMONTH-97))|(1<<(SqlBaseParserNEXT-97))|(1<<(SqlBaseParserNFC-97))|(1<<(SqlBaseParserNFD-97))|(1<<(SqlBaseParserNFKC-97))|(1<<(SqlBaseParserNFKD-97))|(1<<(SqlBaseParserNO-97))|(1<<(SqlBaseParserNONE-97))|(1<<(SqlBaseParserNORMALIZE-97))|(1<<(SqlBaseParserNOT-97))|(1<<(SqlBaseParserNULL-97))|(1<<(SqlBaseParserNULLIF-97))|(1<<(SqlBaseParserNULLS-97))|(1<<(SqlBaseParserOFFSET-97))|(1<<(SqlBaseParserONLY-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBaseParserOPTION-129))|(1<<(SqlBaseParserORDINALITY-129))|(1<<(SqlBaseParserOUTPUT-129))|(1<<(SqlBaseParserOVER-129))|(1<<(SqlBaseParserPARTITION-129))|(1<<(SqlBaseParserPARTITIONS-129))|(1<<(SqlBaseParserPATH-129))|(1<<(SqlBaseParserPOSITION-129))|(1<<(SqlBaseParserPRECEDING-129))|(1<<(SqlBaseParserPRECISION-129))|(1<<(SqlBaseParserPRIVILEGES-129))|(1<<(SqlBaseParserPROPERTIES-129))|(1<<(SqlBaseParserRANGE-129))|(1<<(SqlBaseParserREAD-129))|(1<<(SqlBaseParserREFRESH-129))|(1<<(SqlBaseParserRENAME-129))|(1<<(SqlBaseParserREPEATABLE-129))|(1<<(SqlBaseParserREPLACE-129))|(1<<(SqlBaseParserRESET-129))|(1<<(SqlBaseParserRESPECT-129))|(1<<(SqlBaseParserRESTRICT-129))|(1<<(SqlBaseParserREVOKE-129))|(1<<(SqlBaseParserROLE-129))|(1<<(SqlBaseParserROLES-129))|(1<<(SqlBaseParserROLLBACK-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBaseParserROW-161))|(1<<(SqlBaseParserROWS-161))|(1<<(SqlBaseParserSCHEMA-161))|(1<<(SqlBaseParserSCHEMAS-161))|(1<<(SqlBaseParserSECOND-161))|(1<<(SqlBaseParserSECURITY-161))|(1<<(SqlBaseParserSERIALIZABLE-161))|(1<<(SqlBaseParserSESSION-161))|(1<<(SqlBaseParserSET-161))|(1<<(SqlBaseParserSETS-161))|(1<<(SqlBaseParserSHOW-161))|(1<<(SqlBaseParserSOME-161))|(1<<(SqlBaseParserSTART-161))|(1<<(SqlBaseParserSTATS-161))|(1<<(SqlBaseParserSUBSTRING-161))|(1<<(SqlBaseParserSYSTEM-161))|(1<<(SqlBaseParserTABLES-161))|(1<<(SqlBaseParserTABLESAMPLE-161))|(1<<(SqlBaseParserTEXT-161))|(1<<(SqlBaseParserTIES-161))|(1<<(SqlBaseParserTIME-161))|(1<<(SqlBaseParserTIMESTAMP-161))|(1<<(SqlBaseParserTO-161))|(1<<(SqlBaseParserTRANSACTION-161))|(1<<(SqlBaseParserTRUE-161))|(1<<(SqlBaseParserTRY_CAST-161))|(1<<(SqlBaseParserTYPE-161))|(1<<(SqlBaseParserUNBOUNDED-161)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(SqlBaseParserUNCOMMITTED-193))|(1<<(SqlBaseParserUSE-193))|(1<<(SqlBaseParserUSER-193))|(1<<(SqlBaseParserVALIDATE-193))|(1<<(SqlBaseParserVERBOSE-193))|(1<<(SqlBaseParserVIEW-193))|(1<<(SqlBaseParserWITHOUT-193))|(1<<(SqlBaseParserWORK-193))|(1<<(SqlBaseParserWRITE-193))|(1<<(SqlBaseParserYEAR-193))|(1<<(SqlBaseParserZONE-193))|(1<<(SqlBaseParserPLUS-193))|(1<<(SqlBaseParserMINUS-193))|(1<<(SqlBaseParserSTRING-193))|(1<<(SqlBaseParserUNICODE_STRING-193)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserPARAMETER-225)))) != 0) {
			{
				p.SetState(358)
				p.Expression()
			}
			p.SetState(363)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__2 {
				{
					p.SetState(359)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(360)
					p.Expression()
				}

				p.SetState(365)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(368)
			p.Match(SqlBaseParserT__1)
		}

	case 4:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(369)
			p.Match(SqlBaseParserGROUPING)
		}
		{
			p.SetState(370)
			p.Match(SqlBaseParserSETS)
		}
		{
			p.SetState(371)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(372)
			p.GroupingSet()
		}
		p.SetState(377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__2 {
			{
				p.SetState(373)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(374)
				p.GroupingSet()
			}

			p.SetState(379)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(380)
			p.Match(SqlBaseParserT__1)
		}

	}

	return localctx
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingSet
	return p
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (s *GroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SqlBaseParserRULE_groupingSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(384)
			p.Match(SqlBaseParserT__0)
		}
		p.SetState(393)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__0)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserAUTHORIZATION)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS)|(1<<SqlBaseParserCOMMENT)|(1<<SqlBaseParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_PATH-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserDOUBLE-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32))|(1<<(SqlBaseParserEXPLAIN-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFETCH-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserGROUPS-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64))|(1<<(SqlBaseParserIO-64)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlBaseParserISOLATION-97))|(1<<(SqlBaseParserJSON-97))|(1<<(SqlBaseParserLAST-97))|(1<<(SqlBaseParserLATERAL-97))|(1<<(SqlBaseParserLEVEL-97))|(1<<(SqlBaseParserLIMIT-97))|(1<<(SqlBaseParserLOCALTIME-97))|(1<<(SqlBaseParserLOCALTIMESTAMP-97))|(1<<(SqlBaseParserLOGICAL-97))|(1<<(SqlBaseParserMAP-97))|(1<<(SqlBaseParserMATERIALIZED-97))|(1<<(SqlBaseParserMINUTE-97))|(1<<(SqlBaseParserMONTH-97))|(1<<(SqlBaseParserNEXT-97))|(1<<(SqlBaseParserNFC-97))|(1<<(SqlBaseParserNFD-97))|(1<<(SqlBaseParserNFKC-97))|(1<<(SqlBaseParserNFKD-97))|(1<<(SqlBaseParserNO-97))|(1<<(SqlBaseParserNONE-97))|(1<<(SqlBaseParserNORMALIZE-97))|(1<<(SqlBaseParserNOT-97))|(1<<(SqlBaseParserNULL-97))|(1<<(SqlBaseParserNULLIF-97))|(1<<(SqlBaseParserNULLS-97))|(1<<(SqlBaseParserOFFSET-97))|(1<<(SqlBaseParserONLY-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBaseParserOPTION-129))|(1<<(SqlBaseParserORDINALITY-129))|(1<<(SqlBaseParserOUTPUT-129))|(1<<(SqlBaseParserOVER-129))|(1<<(SqlBaseParserPARTITION-129))|(1<<(SqlBaseParserPARTITIONS-129))|(1<<(SqlBaseParserPATH-129))|(1<<(SqlBaseParserPOSITION-129))|(1<<(SqlBaseParserPRECEDING-129))|(1<<(SqlBaseParserPRECISION-129))|(1<<(SqlBaseParserPRIVILEGES-129))|(1<<(SqlBaseParserPROPERTIES-129))|(1<<(SqlBaseParserRANGE-129))|(1<<(SqlBaseParserREAD-129))|(1<<(SqlBaseParserREFRESH-129))|(1<<(SqlBaseParserRENAME-129))|(1<<(SqlBaseParserREPEATABLE-129))|(1<<(SqlBaseParserREPLACE-129))|(1<<(SqlBaseParserRESET-129))|(1<<(SqlBaseParserRESPECT-129))|(1<<(SqlBaseParserRESTRICT-129))|(1<<(SqlBaseParserREVOKE-129))|(1<<(SqlBaseParserROLE-129))|(1<<(SqlBaseParserROLES-129))|(1<<(SqlBaseParserROLLBACK-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBaseParserROW-161))|(1<<(SqlBaseParserROWS-161))|(1<<(SqlBaseParserSCHEMA-161))|(1<<(SqlBaseParserSCHEMAS-161))|(1<<(SqlBaseParserSECOND-161))|(1<<(SqlBaseParserSECURITY-161))|(1<<(SqlBaseParserSERIALIZABLE-161))|(1<<(SqlBaseParserSESSION-161))|(1<<(SqlBaseParserSET-161))|(1<<(SqlBaseParserSETS-161))|(1<<(SqlBaseParserSHOW-161))|(1<<(SqlBaseParserSOME-161))|(1<<(SqlBaseParserSTART-161))|(1<<(SqlBaseParserSTATS-161))|(1<<(SqlBaseParserSUBSTRING-161))|(1<<(SqlBaseParserSYSTEM-161))|(1<<(SqlBaseParserTABLES-161))|(1<<(SqlBaseParserTABLESAMPLE-161))|(1<<(SqlBaseParserTEXT-161))|(1<<(SqlBaseParserTIES-161))|(1<<(SqlBaseParserTIME-161))|(1<<(SqlBaseParserTIMESTAMP-161))|(1<<(SqlBaseParserTO-161))|(1<<(SqlBaseParserTRANSACTION-161))|(1<<(SqlBaseParserTRUE-161))|(1<<(SqlBaseParserTRY_CAST-161))|(1<<(SqlBaseParserTYPE-161))|(1<<(SqlBaseParserUNBOUNDED-161)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(SqlBaseParserUNCOMMITTED-193))|(1<<(SqlBaseParserUSE-193))|(1<<(SqlBaseParserUSER-193))|(1<<(SqlBaseParserVALIDATE-193))|(1<<(SqlBaseParserVERBOSE-193))|(1<<(SqlBaseParserVIEW-193))|(1<<(SqlBaseParserWITHOUT-193))|(1<<(SqlBaseParserWORK-193))|(1<<(SqlBaseParserWRITE-193))|(1<<(SqlBaseParserYEAR-193))|(1<<(SqlBaseParserZONE-193))|(1<<(SqlBaseParserPLUS-193))|(1<<(SqlBaseParserMINUS-193))|(1<<(SqlBaseParserSTRING-193))|(1<<(SqlBaseParserUNICODE_STRING-193)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserPARAMETER-225)))) != 0) {
			{
				p.SetState(385)
				p.Expression()
			}
			p.SetState(390)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__2 {
				{
					p.SetState(386)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(387)
					p.Expression()
				}

				p.SetState(392)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(395)
			p.Match(SqlBaseParserT__1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(396)
			p.Expression()
		}

	}

	return localctx
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedQuery
	return p
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IIdentifierContext { return s.name }

func (s *NamedQueryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedQueryContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (s *NamedQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNamedQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SqlBaseParserRULE_namedQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)

		var _x = p.Identifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserT__0 {
		{
			p.SetState(400)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(403)
		p.Match(SqlBaseParserAS)
	}
	{
		p.SetState(404)
		p.Match(SqlBaseParserT__0)
	}
	{
		p.SetState(405)
		p.Query()
	}
	{
		p.SetState(406)
		p.Match(SqlBaseParserT__1)
	}

	return localctx
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setQuantifier
	return p
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSetQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SqlBaseParserRULE_setQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(408)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_selectItem
	return p
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyFrom(ctx *SelectItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	*SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *SelectAllContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *SelectAllContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

func (s *SelectAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSelectAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectSingleContext struct {
	*SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (s *SelectSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSelectSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SqlBaseParserRULE_selectItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(410)
			p.Expression()
		}
		p.SetState(415)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			p.SetState(412)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserAS {
				{
					p.SetState(411)
					p.Match(SqlBaseParserAS)
				}

			}
			{
				p.SetState(414)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(417)
			p.primaryExpression(0)
		}
		{
			p.SetState(418)
			p.Match(SqlBaseParserT__3)
		}
		{
			p.SetState(419)
			p.Match(SqlBaseParserASTERISK)
		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(420)
				p.Match(SqlBaseParserAS)
			}
			{
				p.SetState(421)
				p.ColumnAliases()
			}

		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(424)
			p.Match(SqlBaseParserASTERISK)
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyFrom(ctx *RelationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	*RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) SampledRelation() ISampledRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampledRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

func (s *RelationDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRelationDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type JoinRelationContext struct {
	*RelationContext
	left          IRelationContext
	right         ISampledRelationContext
	rightRelation IRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IRelationContext { return s.left }

func (s *JoinRelationContext) GetRight() ISampledRelationContext { return s.right }

func (s *JoinRelationContext) GetRightRelation() IRelationContext { return s.rightRelation }

func (s *JoinRelationContext) SetLeft(v IRelationContext) { s.left = v }

func (s *JoinRelationContext) SetRight(v ISampledRelationContext) { s.right = v }

func (s *JoinRelationContext) SetRightRelation(v IRelationContext) { s.rightRelation = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *JoinRelationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *JoinRelationContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCROSS, 0)
}

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJOIN, 0)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinCriteriaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNATURAL, 0)
}

func (s *JoinRelationContext) SampledRelation() ISampledRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampledRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (s *JoinRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitJoinRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Relation() (localctx IRelationContext) {
	return p.relation(0)
}

func (p *SqlBaseParser) relation(_p int) (localctx IRelationContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRelationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 32
	p.EnterRecursionRule(localctx, 32, SqlBaseParserRULE_relation, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewRelationDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(428)
		p.SampledRelation()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewJoinRelationContext(p, NewRelationContext(p, _parentctx, _parentState))
			localctx.(*JoinRelationContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_relation)
			p.SetState(430)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			p.SetState(444)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SqlBaseParserCROSS:
				{
					p.SetState(431)
					p.Match(SqlBaseParserCROSS)
				}
				{
					p.SetState(432)
					p.Match(SqlBaseParserJOIN)
				}
				{
					p.SetState(433)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			case SqlBaseParserFULL, SqlBaseParserINNER, SqlBaseParserJOIN, SqlBaseParserLEFT, SqlBaseParserRIGHT:
				{
					p.SetState(434)
					p.JoinType()
				}
				{
					p.SetState(435)
					p.Match(SqlBaseParserJOIN)
				}
				{
					p.SetState(436)

					var _x = p.relation(0)

					localctx.(*JoinRelationContext).rightRelation = _x
				}
				{
					p.SetState(437)
					p.JoinCriteria()
				}

			case SqlBaseParserNATURAL:
				{
					p.SetState(439)
					p.Match(SqlBaseParserNATURAL)
				}
				{
					p.SetState(440)
					p.JoinType()
				}
				{
					p.SetState(441)
					p.Match(SqlBaseParserJOIN)
				}
				{
					p.SetState(442)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(450)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
	}

	return localctx
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinType
	return p
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINNER, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFULL, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (s *JoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SqlBaseParserRULE_joinType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(466)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserINNER, SqlBaseParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserINNER {
			{
				p.SetState(451)
				p.Match(SqlBaseParserINNER)
			}

		}

	case SqlBaseParserLEFT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(454)
			p.Match(SqlBaseParserLEFT)
		}
		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(455)
				p.Match(SqlBaseParserOUTER)
			}

		}

	case SqlBaseParserRIGHT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(458)
			p.Match(SqlBaseParserRIGHT)
		}
		p.SetState(460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(459)
				p.Match(SqlBaseParserOUTER)
			}

		}

	case SqlBaseParserFULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(462)
			p.Match(SqlBaseParserFULL)
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(463)
				p.Match(SqlBaseParserOUTER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinCriteria
	return p
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitJoinCriteria(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SqlBaseParserRULE_joinCriteria)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(482)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(468)
			p.Match(SqlBaseParserON)
		}
		{
			p.SetState(469)
			p.booleanExpression(0)
		}

	case SqlBaseParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(470)
			p.Match(SqlBaseParserUSING)
		}
		{
			p.SetState(471)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(472)
			p.Identifier()
		}
		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__2 {
			{
				p.SetState(473)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(474)
				p.Identifier()
			}

			p.SetState(479)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(480)
			p.Match(SqlBaseParserT__1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISampledRelationContext is an interface to support dynamic dispatch.
type ISampledRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPercentage returns the percentage rule contexts.
	GetPercentage() IExpressionContext

	// SetPercentage sets the percentage rule contexts.
	SetPercentage(IExpressionContext)

	// IsSampledRelationContext differentiates from other interfaces.
	IsSampledRelationContext()
}

type SampledRelationContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	percentage IExpressionContext
}

func NewEmptySampledRelationContext() *SampledRelationContext {
	var p = new(SampledRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampledRelation
	return p
}

func (*SampledRelationContext) IsSampledRelationContext() {}

func NewSampledRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampledRelationContext {
	var p = new(SampledRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sampledRelation

	return p
}

func (s *SampledRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *SampledRelationContext) GetPercentage() IExpressionContext { return s.percentage }

func (s *SampledRelationContext) SetPercentage(v IExpressionContext) { s.percentage = v }

func (s *SampledRelationContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *SampledRelationContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLESAMPLE, 0)
}

func (s *SampledRelationContext) SampleType() ISampleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampleTypeContext)
}

func (s *SampledRelationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampledRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampledRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampledRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSampledRelation(s)
	}
}

func (s *SampledRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSampledRelation(s)
	}
}

func (s *SampledRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSampledRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SampledRelation() (localctx ISampledRelationContext) {
	localctx = NewSampledRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SqlBaseParserRULE_sampledRelation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(484)
		p.AliasedRelation()
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(485)
			p.Match(SqlBaseParserTABLESAMPLE)
		}
		{
			p.SetState(486)
			p.SampleType()
		}
		{
			p.SetState(487)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(488)

			var _x = p.Expression()

			localctx.(*SampledRelationContext).percentage = _x
		}
		{
			p.SetState(489)
			p.Match(SqlBaseParserT__1)
		}

	}

	return localctx
}

// ISampleTypeContext is an interface to support dynamic dispatch.
type ISampleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSampleTypeContext differentiates from other interfaces.
	IsSampleTypeContext()
}

type SampleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleTypeContext() *SampleTypeContext {
	var p = new(SampleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampleType
	return p
}

func (*SampleTypeContext) IsSampleTypeContext() {}

func NewSampleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleTypeContext {
	var p = new(SampleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sampleType

	return p
}

func (s *SampleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleTypeContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBERNOULLI, 0)
}

func (s *SampleTypeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM, 0)
}

func (s *SampleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSampleType(s)
	}
}

func (s *SampleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSampleType(s)
	}
}

func (s *SampleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSampleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SampleType() (localctx ISampleTypeContext) {
	localctx = NewSampleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SqlBaseParserRULE_sampleType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(493)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserBERNOULLI || _la == SqlBaseParserSYSTEM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation
	return p
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *AliasedRelationContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitAliasedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SqlBaseParserRULE_aliasedRelation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.RelationPrimary()
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAS {
			{
				p.SetState(496)
				p.Match(SqlBaseParserAS)
			}

		}
		{
			p.SetState(499)
			p.Identifier()
		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(500)
				p.ColumnAliases()
			}

		}

	}

	return localctx
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnAliases
	return p
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SqlBaseParserRULE_columnAliases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(505)
		p.Match(SqlBaseParserT__0)
	}
	{
		p.SetState(506)
		p.Identifier()
	}
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__2 {
		{
			p.SetState(507)
			p.Match(SqlBaseParserT__2)
		}
		{
			p.SetState(508)
			p.Identifier()
		}

		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(514)
		p.Match(SqlBaseParserT__1)
	}

	return localctx
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationPrimary
	return p
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyFrom(ctx *RelationPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryRelationContext struct {
	*RelationPrimaryContext
}

func NewSubqueryRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryRelationContext {
	var p = new(SubqueryRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryRelationContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubqueryRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedRelationContext struct {
	*RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relation() IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitParenthesizedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnnestContext struct {
	*RelationPrimaryContext
}

func NewUnnestContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnnestContext {
	var p = new(UnnestContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *UnnestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnnestContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNNEST, 0)
}

func (s *UnnestContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *UnnestContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnnestContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *UnnestContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDINALITY, 0)
}

func (s *UnnestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnnest(s)
	}
}

func (s *UnnestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnnest(s)
	}
}

func (s *UnnestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUnnest(s)

	default:
		return t.VisitChildren(s)
	}
}

type LateralContext struct {
	*RelationPrimaryContext
}

func NewLateralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LateralContext {
	var p = new(LateralContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *LateralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *LateralContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *LateralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLateral(s)
	}
}

func (s *LateralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLateral(s)
	}
}

func (s *LateralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLateral(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableNameContext struct {
	*RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SqlBaseParserRULE_relationPrimary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(516)
			p.QualifiedName()
		}

	case 2:
		localctx = NewSubqueryRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(517)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(518)
			p.Query()
		}
		{
			p.SetState(519)
			p.Match(SqlBaseParserT__1)
		}

	case 3:
		localctx = NewUnnestContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(521)
			p.Match(SqlBaseParserUNNEST)
		}
		{
			p.SetState(522)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(523)
			p.Expression()
		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__2 {
			{
				p.SetState(524)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(525)
				p.Expression()
			}

			p.SetState(530)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(531)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(534)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(532)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(533)
				p.Match(SqlBaseParserORDINALITY)
			}

		}

	case 4:
		localctx = NewLateralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(536)
			p.Match(SqlBaseParserLATERAL)
		}
		{
			p.SetState(537)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(538)
			p.Query()
		}
		{
			p.SetState(539)
			p.Match(SqlBaseParserT__1)
		}

	case 5:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(541)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(542)
			p.relation(0)
		}
		{
			p.SetState(543)
			p.Match(SqlBaseParserT__1)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SqlBaseParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(547)
		p.booleanExpression(0)
	}

	return localctx
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanExpression
	return p
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyFrom(ctx *BooleanExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	*BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

func (s *LogicalNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLogicalNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicatedContext struct {
	*BooleanExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPredicated(s)
	}
}

func (s *PredicatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitPredicated(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalBinaryContext struct {
	*BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLogicalBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *SqlBaseParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 50
	p.EnterRecursionRule(localctx, 50, SqlBaseParserRULE_booleanExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(556)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserT__0, SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserAUTHORIZATION, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCASCADE, SqlBaseParserCASE, SqlBaseParserCAST, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_DATE, SqlBaseParserCURRENT_PATH, SqlBaseParserCURRENT_TIME, SqlBaseParserCURRENT_TIMESTAMP, SqlBaseParserCURRENT_USER, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserDOUBLE, SqlBaseParserEXCLUDING, SqlBaseParserEXISTS, SqlBaseParserEXPLAIN, SqlBaseParserEXTRACT, SqlBaseParserFALSE, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserGROUPING, SqlBaseParserGROUPS, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOCALTIME, SqlBaseParserLOCALTIMESTAMP, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNORMALIZE, SqlBaseParserNULL, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRECISION, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRUE, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWITHOUT, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserPLUS, SqlBaseParserMINUS, SqlBaseParserSTRING, SqlBaseParserUNICODE_STRING, SqlBaseParserBINARY_LITERAL, SqlBaseParserINTEGER_VALUE, SqlBaseParserDECIMAL_VALUE, SqlBaseParserDOUBLE_VALUE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserPARAMETER:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(550)
			p.valueExpression(0)
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(551)
				p.Predicate()
			}

		}

	case SqlBaseParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(554)
			p.Match(SqlBaseParserNOT)
		}
		{
			p.SetState(555)
			p.booleanExpression(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(564)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(558)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(559)

					var _m = p.Match(SqlBaseParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(560)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(561)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(562)

					var _m = p.Match(SqlBaseParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(563)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			}

		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type LikeContext struct {
	*PredicateContext
	pattern IValueExpressionContext
	escape  IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) GetEscape() IValueExpressionContext { return s.escape }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) SetEscape(v IValueExpressionContext) { s.escape = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *LikeContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *LikeContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLike(s)
	}
}

func (s *LikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLike(s)

	default:
		return t.VisitChildren(s)
	}
}

type InSubqueryContext struct {
	*PredicateContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *InSubqueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

func (s *InSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type DistinctFromContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

func (s *DistinctFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDistinctFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

type InListContext struct {
	*PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInList(s)
	}
}

func (s *InListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitInList(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullPredicateContext struct {
	*PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

func (s *NullPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNullPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenContext struct {
	*PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (s *BetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuantifiedComparisonContext struct {
	*PredicateContext
}

func NewQuantifiedComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantifiedComparisonContext {
	var p = new(QuantifiedComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *QuantifiedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuantifiedComparisonContext) ComparisonQuantifier() IComparisonQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonQuantifierContext)
}

func (s *QuantifiedComparisonContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QuantifiedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQuantifiedComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SqlBaseParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(569)
			p.ComparisonOperator()
		}
		{
			p.SetState(570)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewQuantifiedComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(572)
			p.ComparisonOperator()
		}
		{
			p.SetState(573)
			p.ComparisonQuantifier()
		}
		{
			p.SetState(574)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(575)
			p.Query()
		}
		{
			p.SetState(576)
			p.Match(SqlBaseParserT__1)
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(578)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(581)
			p.Match(SqlBaseParserBETWEEN)
		}
		{
			p.SetState(582)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(583)
			p.Match(SqlBaseParserAND)
		}
		{
			p.SetState(584)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(586)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(589)
			p.Match(SqlBaseParserIN)
		}
		{
			p.SetState(590)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(591)
			p.Expression()
		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__2 {
			{
				p.SetState(592)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(593)
				p.Expression()
			}

			p.SetState(598)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(599)
			p.Match(SqlBaseParserT__1)
		}

	case 5:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(601)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(604)
			p.Match(SqlBaseParserIN)
		}
		{
			p.SetState(605)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(606)
			p.Query()
		}
		{
			p.SetState(607)
			p.Match(SqlBaseParserT__1)
		}

	case 6:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(609)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(612)
			p.Match(SqlBaseParserLIKE)
		}
		{
			p.SetState(613)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(614)
				p.Match(SqlBaseParserESCAPE)
			}
			{
				p.SetState(615)

				var _x = p.valueExpression(0)

				localctx.(*LikeContext).escape = _x
			}

		}

	case 7:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(618)
			p.Match(SqlBaseParserIS)
		}
		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(619)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(622)
			p.Match(SqlBaseParserNULL)
		}

	case 8:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(623)
			p.Match(SqlBaseParserIS)
		}
		p.SetState(625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(624)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(627)
			p.Match(SqlBaseParserDISTINCT)
		}
		{
			p.SetState(628)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(629)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	}

	return localctx
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_valueExpression
	return p
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyFrom(ctx *ValueExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	*ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitValueExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConcatenationContext struct {
	*ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (s *ConcatenationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitConcatenation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticBinaryContext struct {
	*ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitArithmeticBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticUnaryContext struct {
	*ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitArithmeticUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

type AtTimeZoneContext struct {
	*ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAT, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeZoneSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitAtTimeZone(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *SqlBaseParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 54
	p.EnterRecursionRule(localctx, 54, SqlBaseParserRULE_valueExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(633)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(634)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(635)
			p.valueExpression(4)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(650)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(638)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(639)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-219)&-(0x1f+1)) == 0 && ((1<<uint((_la-219)))&((1<<(SqlBaseParserASTERISK-219))|(1<<(SqlBaseParserSLASH-219))|(1<<(SqlBaseParserPERCENT-219)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(640)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(641)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(642)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(643)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(644)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(645)
					p.Match(SqlBaseParserCONCAT)
				}
				{
					p.SetState(646)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 4:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(647)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(648)
					p.Match(SqlBaseParserAT)
				}
				{
					p.SetState(649)
					p.TimeZoneSpecifier()
				}

			}

		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyFrom(ctx *PrimaryExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	*PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDereference(s)
	}
}

func (s *DereferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDereference(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeConstructorContext struct {
	*PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) Gstring() IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *TypeConstructorContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE, 0)
}

func (s *TypeConstructorContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECISION, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTypeConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialDateTimeFunctionContext struct {
	*PrimaryExpressionContext
	name      antlr.Token
	precision antlr.Token
}

func NewSpecialDateTimeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeFunctionContext {
	var p = new(SpecialDateTimeFunctionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SpecialDateTimeFunctionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeFunctionContext) GetPrecision() antlr.Token { return s.precision }

func (s *SpecialDateTimeFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeFunctionContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *SpecialDateTimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeFunctionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeFunctionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCALTIME, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSpecialDateTimeFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubstringContext struct {
	*PrimaryExpressionContext
}

func NewSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstringContext {
	var p = new(SubstringContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTRING, 0)
}

func (s *SubstringContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *SubstringContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *SubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *SubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubstring(s)
	}
}

func (s *SubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubstring(s)
	}
}

func (s *SubstringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubstring(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastContext struct {
	*PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CastContext) Gtype() IGtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGtypeContext)
}

func (s *CastContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRY_CAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCast(s)
	}
}

func (s *CastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaContext struct {
	*PrimaryExpressionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLambda(s)
	}
}

func (s *LambdaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLambda(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	*PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParameterContext struct {
	*PrimaryExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARAMETER, 0)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

type NormalizeContext struct {
	*PrimaryExpressionContext
}

func NewNormalizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizeContext {
	var p = new(NormalizeContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NormalizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizeContext) NORMALIZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNORMALIZE, 0)
}

func (s *NormalizeContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *NormalizeContext) NormalForm() INormalFormContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalFormContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalFormContext)
}

func (s *NormalizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNormalize(s)
	}
}

func (s *NormalizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNormalize(s)
	}
}

func (s *NormalizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNormalize(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalLiteralContext struct {
	*PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitIntervalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumericLiteralContext struct {
	*PrimaryExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleCaseContext struct {
	*PrimaryExpressionContext
	operand        IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetOperand() IExpressionContext { return s.operand }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetOperand(v IExpressionContext) { s.operand = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

func (s *SimpleCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSimpleCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

func (s *ColumnReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitColumnReference(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullLiteralContext struct {
	*PrimaryExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type RowConstructorContext struct {
	*PrimaryExpressionContext
}

func NewRowConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowConstructorContext {
	var p = new(RowConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RowConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RowConstructorContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (s *RowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubscriptContext struct {
	*PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (s *SubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentPathContext struct {
	*PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentPathContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentPathContext {
	var p = new(CurrentPathContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentPathContext) GetName() antlr.Token { return s.name }

func (s *CurrentPathContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentPathContext) CURRENT_PATH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_PATH, 0)
}

func (s *CurrentPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentPath(s)
	}
}

func (s *CurrentPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentPath(s)
	}
}

func (s *CurrentPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCurrentPath(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionContext struct {
	*PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubqueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINARY_LITERAL, 0)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBinaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentUserContext struct {
	*PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentUserContext) GetName() antlr.Token { return s.name }

func (s *CurrentUserContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_USER, 0)
}

func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

func (s *CurrentUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCurrentUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractContext struct {
	*PrimaryExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExtract(s)
	}
}

func (s *ExtractContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExtract(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralContext struct {
	*PrimaryExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) Gstring() IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayConstructorContext struct {
	*PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitArrayConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallContext struct {
	*PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *FunctionCallContext) Filter() IFilterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterContext)
}

func (s *FunctionCallContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *FunctionCallContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *FunctionCallContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsContext struct {
	*PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *ExistsContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExists(s)
	}
}

func (s *ExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type PositionContext struct {
	*PrimaryExpressionContext
}

func NewPositionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionContext {
	var p = new(PositionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *PositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPOSITION, 0)
}

func (s *PositionContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *PositionContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PositionContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *PositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPosition(s)
	}
}

func (s *PositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPosition(s)
	}
}

func (s *PositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitPosition(s)

	default:
		return t.VisitChildren(s)
	}
}

type SearchedCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (s *SearchedCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSearchedCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type GroupingOperationContext struct {
	*PrimaryExpressionContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *GroupingOperationContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *GroupingOperationContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *SqlBaseParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 56
	p.EnterRecursionRule(localctx, 56, SqlBaseParserRULE_primaryExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(656)
			p.Match(SqlBaseParserNULL)
		}

	case 2:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(657)
			p.Interval()
		}

	case 3:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(658)
			p.Identifier()
		}
		{
			p.SetState(659)
			p.Gstring()
		}

	case 4:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(661)
			p.Match(SqlBaseParserDOUBLE)
		}
		{
			p.SetState(662)
			p.Match(SqlBaseParserPRECISION)
		}
		{
			p.SetState(663)
			p.Gstring()
		}

	case 5:
		localctx = NewNumericLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(664)
			p.Number()
		}

	case 6:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(665)
			p.BooleanValue()
		}

	case 7:
		localctx = NewStringLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(666)
			p.Gstring()
		}

	case 8:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(667)
			p.Match(SqlBaseParserBINARY_LITERAL)
		}

	case 9:
		localctx = NewParameterContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(668)
			p.Match(SqlBaseParserPARAMETER)
		}

	case 10:
		localctx = NewPositionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(669)
			p.Match(SqlBaseParserPOSITION)
		}
		{
			p.SetState(670)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(671)
			p.valueExpression(0)
		}
		{
			p.SetState(672)
			p.Match(SqlBaseParserIN)
		}
		{
			p.SetState(673)
			p.valueExpression(0)
		}
		{
			p.SetState(674)
			p.Match(SqlBaseParserT__1)
		}

	case 11:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(676)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(677)
			p.Expression()
		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserT__2 {
			{
				p.SetState(678)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(679)
				p.Expression()
			}

			p.SetState(682)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(684)
			p.Match(SqlBaseParserT__1)
		}

	case 12:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(686)
			p.Match(SqlBaseParserROW)
		}
		{
			p.SetState(687)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(688)
			p.Expression()
		}
		p.SetState(693)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__2 {
			{
				p.SetState(689)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(690)
				p.Expression()
			}

			p.SetState(695)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(696)
			p.Match(SqlBaseParserT__1)
		}

	case 13:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(698)
			p.QualifiedName()
		}
		{
			p.SetState(699)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(700)
			p.Match(SqlBaseParserASTERISK)
		}
		{
			p.SetState(701)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(703)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(702)
				p.Filter()
			}

		}

	case 14:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(705)
			p.QualifiedName()
		}
		{
			p.SetState(706)
			p.Match(SqlBaseParserT__0)
		}
		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__0)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserAUTHORIZATION)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS)|(1<<SqlBaseParserCOMMENT)|(1<<SqlBaseParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_PATH-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDISTINCT-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserDOUBLE-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32))|(1<<(SqlBaseParserEXPLAIN-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFETCH-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserGROUPS-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64))|(1<<(SqlBaseParserIO-64)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlBaseParserISOLATION-97))|(1<<(SqlBaseParserJSON-97))|(1<<(SqlBaseParserLAST-97))|(1<<(SqlBaseParserLATERAL-97))|(1<<(SqlBaseParserLEVEL-97))|(1<<(SqlBaseParserLIMIT-97))|(1<<(SqlBaseParserLOCALTIME-97))|(1<<(SqlBaseParserLOCALTIMESTAMP-97))|(1<<(SqlBaseParserLOGICAL-97))|(1<<(SqlBaseParserMAP-97))|(1<<(SqlBaseParserMATERIALIZED-97))|(1<<(SqlBaseParserMINUTE-97))|(1<<(SqlBaseParserMONTH-97))|(1<<(SqlBaseParserNEXT-97))|(1<<(SqlBaseParserNFC-97))|(1<<(SqlBaseParserNFD-97))|(1<<(SqlBaseParserNFKC-97))|(1<<(SqlBaseParserNFKD-97))|(1<<(SqlBaseParserNO-97))|(1<<(SqlBaseParserNONE-97))|(1<<(SqlBaseParserNORMALIZE-97))|(1<<(SqlBaseParserNOT-97))|(1<<(SqlBaseParserNULL-97))|(1<<(SqlBaseParserNULLIF-97))|(1<<(SqlBaseParserNULLS-97))|(1<<(SqlBaseParserOFFSET-97))|(1<<(SqlBaseParserONLY-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBaseParserOPTION-129))|(1<<(SqlBaseParserORDINALITY-129))|(1<<(SqlBaseParserOUTPUT-129))|(1<<(SqlBaseParserOVER-129))|(1<<(SqlBaseParserPARTITION-129))|(1<<(SqlBaseParserPARTITIONS-129))|(1<<(SqlBaseParserPATH-129))|(1<<(SqlBaseParserPOSITION-129))|(1<<(SqlBaseParserPRECEDING-129))|(1<<(SqlBaseParserPRECISION-129))|(1<<(SqlBaseParserPRIVILEGES-129))|(1<<(SqlBaseParserPROPERTIES-129))|(1<<(SqlBaseParserRANGE-129))|(1<<(SqlBaseParserREAD-129))|(1<<(SqlBaseParserREFRESH-129))|(1<<(SqlBaseParserRENAME-129))|(1<<(SqlBaseParserREPEATABLE-129))|(1<<(SqlBaseParserREPLACE-129))|(1<<(SqlBaseParserRESET-129))|(1<<(SqlBaseParserRESPECT-129))|(1<<(SqlBaseParserRESTRICT-129))|(1<<(SqlBaseParserREVOKE-129))|(1<<(SqlBaseParserROLE-129))|(1<<(SqlBaseParserROLES-129))|(1<<(SqlBaseParserROLLBACK-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBaseParserROW-161))|(1<<(SqlBaseParserROWS-161))|(1<<(SqlBaseParserSCHEMA-161))|(1<<(SqlBaseParserSCHEMAS-161))|(1<<(SqlBaseParserSECOND-161))|(1<<(SqlBaseParserSECURITY-161))|(1<<(SqlBaseParserSERIALIZABLE-161))|(1<<(SqlBaseParserSESSION-161))|(1<<(SqlBaseParserSET-161))|(1<<(SqlBaseParserSETS-161))|(1<<(SqlBaseParserSHOW-161))|(1<<(SqlBaseParserSOME-161))|(1<<(SqlBaseParserSTART-161))|(1<<(SqlBaseParserSTATS-161))|(1<<(SqlBaseParserSUBSTRING-161))|(1<<(SqlBaseParserSYSTEM-161))|(1<<(SqlBaseParserTABLES-161))|(1<<(SqlBaseParserTABLESAMPLE-161))|(1<<(SqlBaseParserTEXT-161))|(1<<(SqlBaseParserTIES-161))|(1<<(SqlBaseParserTIME-161))|(1<<(SqlBaseParserTIMESTAMP-161))|(1<<(SqlBaseParserTO-161))|(1<<(SqlBaseParserTRANSACTION-161))|(1<<(SqlBaseParserTRUE-161))|(1<<(SqlBaseParserTRY_CAST-161))|(1<<(SqlBaseParserTYPE-161))|(1<<(SqlBaseParserUNBOUNDED-161)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(SqlBaseParserUNCOMMITTED-193))|(1<<(SqlBaseParserUSE-193))|(1<<(SqlBaseParserUSER-193))|(1<<(SqlBaseParserVALIDATE-193))|(1<<(SqlBaseParserVERBOSE-193))|(1<<(SqlBaseParserVIEW-193))|(1<<(SqlBaseParserWITHOUT-193))|(1<<(SqlBaseParserWORK-193))|(1<<(SqlBaseParserWRITE-193))|(1<<(SqlBaseParserYEAR-193))|(1<<(SqlBaseParserZONE-193))|(1<<(SqlBaseParserPLUS-193))|(1<<(SqlBaseParserMINUS-193))|(1<<(SqlBaseParserSTRING-193))|(1<<(SqlBaseParserUNICODE_STRING-193)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserPARAMETER-225)))) != 0) {
			p.SetState(708)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(707)
					p.SetQuantifier()
				}

			}
			{
				p.SetState(710)
				p.Expression()
			}
			p.SetState(715)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__2 {
				{
					p.SetState(711)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(712)
					p.Expression()
				}

				p.SetState(717)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserORDER {
			{
				p.SetState(720)
				p.Match(SqlBaseParserORDER)
			}
			{
				p.SetState(721)
				p.Match(SqlBaseParserBY)
			}
			{
				p.SetState(722)
				p.SortItem()
			}
			p.SetState(727)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__2 {
				{
					p.SetState(723)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(724)
					p.SortItem()
				}

				p.SetState(729)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(732)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(734)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(733)
				p.Filter()
			}

		}

	case 15:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(736)
			p.Identifier()
		}
		{
			p.SetState(737)
			p.Match(SqlBaseParserT__4)
		}
		{
			p.SetState(738)
			p.Expression()
		}

	case 16:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(740)
			p.Match(SqlBaseParserT__0)
		}
		p.SetState(749)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-8)&-(0x1f+1)) == 0 && ((1<<uint((_la-8)))&((1<<(SqlBaseParserADD-8))|(1<<(SqlBaseParserADMIN-8))|(1<<(SqlBaseParserALL-8))|(1<<(SqlBaseParserANALYZE-8))|(1<<(SqlBaseParserANY-8))|(1<<(SqlBaseParserARRAY-8))|(1<<(SqlBaseParserASC-8))|(1<<(SqlBaseParserAT-8))|(1<<(SqlBaseParserAUTHORIZATION-8))|(1<<(SqlBaseParserBERNOULLI-8))|(1<<(SqlBaseParserCALL-8))|(1<<(SqlBaseParserCASCADE-8))|(1<<(SqlBaseParserCATALOGS-8))|(1<<(SqlBaseParserCOLUMN-8))|(1<<(SqlBaseParserCOLUMNS-8))|(1<<(SqlBaseParserCOMMENT-8))|(1<<(SqlBaseParserCOMMIT-8))|(1<<(SqlBaseParserCOMMITTED-8))|(1<<(SqlBaseParserCURRENT-8)))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SqlBaseParserDATA-44))|(1<<(SqlBaseParserDATE-44))|(1<<(SqlBaseParserDAY-44))|(1<<(SqlBaseParserDEFINER-44))|(1<<(SqlBaseParserDESC-44))|(1<<(SqlBaseParserDISTRIBUTED-44))|(1<<(SqlBaseParserDOUBLE-44))|(1<<(SqlBaseParserEXCLUDING-44))|(1<<(SqlBaseParserEXPLAIN-44))|(1<<(SqlBaseParserFETCH-44))|(1<<(SqlBaseParserFILTER-44))|(1<<(SqlBaseParserFIRST-44))|(1<<(SqlBaseParserFOLLOWING-44))|(1<<(SqlBaseParserFORMAT-44))|(1<<(SqlBaseParserFUNCTIONS-44))|(1<<(SqlBaseParserGRANT-44)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(SqlBaseParserGRANTED-76))|(1<<(SqlBaseParserGRANTS-76))|(1<<(SqlBaseParserGRAPHVIZ-76))|(1<<(SqlBaseParserGROUPS-76))|(1<<(SqlBaseParserHOUR-76))|(1<<(SqlBaseParserIF-76))|(1<<(SqlBaseParserIGNORE-76))|(1<<(SqlBaseParserINCLUDING-76))|(1<<(SqlBaseParserINPUT-76))|(1<<(SqlBaseParserINTERVAL-76))|(1<<(SqlBaseParserINVOKER-76))|(1<<(SqlBaseParserIO-76))|(1<<(SqlBaseParserISOLATION-76))|(1<<(SqlBaseParserJSON-76))|(1<<(SqlBaseParserLAST-76))|(1<<(SqlBaseParserLATERAL-76))|(1<<(SqlBaseParserLEVEL-76))|(1<<(SqlBaseParserLIMIT-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(SqlBaseParserLOGICAL-108))|(1<<(SqlBaseParserMAP-108))|(1<<(SqlBaseParserMATERIALIZED-108))|(1<<(SqlBaseParserMINUTE-108))|(1<<(SqlBaseParserMONTH-108))|(1<<(SqlBaseParserNEXT-108))|(1<<(SqlBaseParserNFC-108))|(1<<(SqlBaseParserNFD-108))|(1<<(SqlBaseParserNFKC-108))|(1<<(SqlBaseParserNFKD-108))|(1<<(SqlBaseParserNO-108))|(1<<(SqlBaseParserNONE-108))|(1<<(SqlBaseParserNULLIF-108))|(1<<(SqlBaseParserNULLS-108))|(1<<(SqlBaseParserOFFSET-108))|(1<<(SqlBaseParserONLY-108))|(1<<(SqlBaseParserOPTION-108))|(1<<(SqlBaseParserORDINALITY-108))|(1<<(SqlBaseParserOUTPUT-108))|(1<<(SqlBaseParserOVER-108))|(1<<(SqlBaseParserPARTITION-108))|(1<<(SqlBaseParserPARTITIONS-108))|(1<<(SqlBaseParserPATH-108))|(1<<(SqlBaseParserPOSITION-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(SqlBaseParserPRECEDING-140))|(1<<(SqlBaseParserPRECISION-140))|(1<<(SqlBaseParserPRIVILEGES-140))|(1<<(SqlBaseParserPROPERTIES-140))|(1<<(SqlBaseParserRANGE-140))|(1<<(SqlBaseParserREAD-140))|(1<<(SqlBaseParserREFRESH-140))|(1<<(SqlBaseParserRENAME-140))|(1<<(SqlBaseParserREPEATABLE-140))|(1<<(SqlBaseParserREPLACE-140))|(1<<(SqlBaseParserRESET-140))|(1<<(SqlBaseParserRESPECT-140))|(1<<(SqlBaseParserRESTRICT-140))|(1<<(SqlBaseParserREVOKE-140))|(1<<(SqlBaseParserROLE-140))|(1<<(SqlBaseParserROLES-140))|(1<<(SqlBaseParserROLLBACK-140))|(1<<(SqlBaseParserROW-140))|(1<<(SqlBaseParserROWS-140))|(1<<(SqlBaseParserSCHEMA-140))|(1<<(SqlBaseParserSCHEMAS-140))|(1<<(SqlBaseParserSECOND-140))|(1<<(SqlBaseParserSECURITY-140))|(1<<(SqlBaseParserSERIALIZABLE-140))|(1<<(SqlBaseParserSESSION-140))|(1<<(SqlBaseParserSET-140))|(1<<(SqlBaseParserSETS-140)))) != 0) || (((_la-172)&-(0x1f+1)) == 0 && ((1<<uint((_la-172)))&((1<<(SqlBaseParserSHOW-172))|(1<<(SqlBaseParserSOME-172))|(1<<(SqlBaseParserSTART-172))|(1<<(SqlBaseParserSTATS-172))|(1<<(SqlBaseParserSUBSTRING-172))|(1<<(SqlBaseParserSYSTEM-172))|(1<<(SqlBaseParserTABLES-172))|(1<<(SqlBaseParserTABLESAMPLE-172))|(1<<(SqlBaseParserTEXT-172))|(1<<(SqlBaseParserTIES-172))|(1<<(SqlBaseParserTIME-172))|(1<<(SqlBaseParserTIMESTAMP-172))|(1<<(SqlBaseParserTO-172))|(1<<(SqlBaseParserTRANSACTION-172))|(1<<(SqlBaseParserTRY_CAST-172))|(1<<(SqlBaseParserTYPE-172))|(1<<(SqlBaseParserUNBOUNDED-172))|(1<<(SqlBaseParserUNCOMMITTED-172))|(1<<(SqlBaseParserUSE-172))|(1<<(SqlBaseParserUSER-172))|(1<<(SqlBaseParserVALIDATE-172))|(1<<(SqlBaseParserVERBOSE-172))|(1<<(SqlBaseParserVIEW-172)))) != 0) || (((_la-206)&-(0x1f+1)) == 0 && ((1<<uint((_la-206)))&((1<<(SqlBaseParserWITHOUT-206))|(1<<(SqlBaseParserWORK-206))|(1<<(SqlBaseParserWRITE-206))|(1<<(SqlBaseParserYEAR-206))|(1<<(SqlBaseParserZONE-206))|(1<<(SqlBaseParserIDENTIFIER-206))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-206))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-206))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-206)))) != 0) {
			{
				p.SetState(741)
				p.Identifier()
			}
			p.SetState(746)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__2 {
				{
					p.SetState(742)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(743)
					p.Identifier()
				}

				p.SetState(748)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(751)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(752)
			p.Match(SqlBaseParserT__4)
		}
		{
			p.SetState(753)
			p.Expression()
		}

	case 17:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(754)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(755)
			p.Query()
		}
		{
			p.SetState(756)
			p.Match(SqlBaseParserT__1)
		}

	case 18:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(758)
			p.Match(SqlBaseParserEXISTS)
		}
		{
			p.SetState(759)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(760)
			p.Query()
		}
		{
			p.SetState(761)
			p.Match(SqlBaseParserT__1)
		}

	case 19:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(763)
			p.Match(SqlBaseParserCASE)
		}
		{
			p.SetState(764)

			var _x = p.Expression()

			localctx.(*SimpleCaseContext).operand = _x
		}
		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(765)
				p.WhenClause()
			}

			p.SetState(768)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(770)
				p.Match(SqlBaseParserELSE)
			}
			{
				p.SetState(771)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(774)
			p.Match(SqlBaseParserEND)
		}

	case 20:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(776)
			p.Match(SqlBaseParserCASE)
		}
		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(777)
				p.WhenClause()
			}

			p.SetState(780)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(784)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(782)
				p.Match(SqlBaseParserELSE)
			}
			{
				p.SetState(783)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(786)
			p.Match(SqlBaseParserEND)
		}

	case 21:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(788)
			p.Match(SqlBaseParserCAST)
		}
		{
			p.SetState(789)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(790)
			p.Expression()
		}
		{
			p.SetState(791)
			p.Match(SqlBaseParserAS)
		}
		{
			p.SetState(792)
			p.gtype(0)
		}
		{
			p.SetState(793)
			p.Match(SqlBaseParserT__1)
		}

	case 22:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(795)
			p.Match(SqlBaseParserTRY_CAST)
		}
		{
			p.SetState(796)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(797)
			p.Expression()
		}
		{
			p.SetState(798)
			p.Match(SqlBaseParserAS)
		}
		{
			p.SetState(799)
			p.gtype(0)
		}
		{
			p.SetState(800)
			p.Match(SqlBaseParserT__1)
		}

	case 23:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(802)
			p.Match(SqlBaseParserARRAY)
		}
		{
			p.SetState(803)
			p.Match(SqlBaseParserT__5)
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__0)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserAUTHORIZATION)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS)|(1<<SqlBaseParserCOMMENT)|(1<<SqlBaseParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_PATH-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserDOUBLE-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32))|(1<<(SqlBaseParserEXPLAIN-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFETCH-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserGROUPS-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64))|(1<<(SqlBaseParserIO-64)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(SqlBaseParserISOLATION-97))|(1<<(SqlBaseParserJSON-97))|(1<<(SqlBaseParserLAST-97))|(1<<(SqlBaseParserLATERAL-97))|(1<<(SqlBaseParserLEVEL-97))|(1<<(SqlBaseParserLIMIT-97))|(1<<(SqlBaseParserLOCALTIME-97))|(1<<(SqlBaseParserLOCALTIMESTAMP-97))|(1<<(SqlBaseParserLOGICAL-97))|(1<<(SqlBaseParserMAP-97))|(1<<(SqlBaseParserMATERIALIZED-97))|(1<<(SqlBaseParserMINUTE-97))|(1<<(SqlBaseParserMONTH-97))|(1<<(SqlBaseParserNEXT-97))|(1<<(SqlBaseParserNFC-97))|(1<<(SqlBaseParserNFD-97))|(1<<(SqlBaseParserNFKC-97))|(1<<(SqlBaseParserNFKD-97))|(1<<(SqlBaseParserNO-97))|(1<<(SqlBaseParserNONE-97))|(1<<(SqlBaseParserNORMALIZE-97))|(1<<(SqlBaseParserNOT-97))|(1<<(SqlBaseParserNULL-97))|(1<<(SqlBaseParserNULLIF-97))|(1<<(SqlBaseParserNULLS-97))|(1<<(SqlBaseParserOFFSET-97))|(1<<(SqlBaseParserONLY-97)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBaseParserOPTION-129))|(1<<(SqlBaseParserORDINALITY-129))|(1<<(SqlBaseParserOUTPUT-129))|(1<<(SqlBaseParserOVER-129))|(1<<(SqlBaseParserPARTITION-129))|(1<<(SqlBaseParserPARTITIONS-129))|(1<<(SqlBaseParserPATH-129))|(1<<(SqlBaseParserPOSITION-129))|(1<<(SqlBaseParserPRECEDING-129))|(1<<(SqlBaseParserPRECISION-129))|(1<<(SqlBaseParserPRIVILEGES-129))|(1<<(SqlBaseParserPROPERTIES-129))|(1<<(SqlBaseParserRANGE-129))|(1<<(SqlBaseParserREAD-129))|(1<<(SqlBaseParserREFRESH-129))|(1<<(SqlBaseParserRENAME-129))|(1<<(SqlBaseParserREPEATABLE-129))|(1<<(SqlBaseParserREPLACE-129))|(1<<(SqlBaseParserRESET-129))|(1<<(SqlBaseParserRESPECT-129))|(1<<(SqlBaseParserRESTRICT-129))|(1<<(SqlBaseParserREVOKE-129))|(1<<(SqlBaseParserROLE-129))|(1<<(SqlBaseParserROLES-129))|(1<<(SqlBaseParserROLLBACK-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBaseParserROW-161))|(1<<(SqlBaseParserROWS-161))|(1<<(SqlBaseParserSCHEMA-161))|(1<<(SqlBaseParserSCHEMAS-161))|(1<<(SqlBaseParserSECOND-161))|(1<<(SqlBaseParserSECURITY-161))|(1<<(SqlBaseParserSERIALIZABLE-161))|(1<<(SqlBaseParserSESSION-161))|(1<<(SqlBaseParserSET-161))|(1<<(SqlBaseParserSETS-161))|(1<<(SqlBaseParserSHOW-161))|(1<<(SqlBaseParserSOME-161))|(1<<(SqlBaseParserSTART-161))|(1<<(SqlBaseParserSTATS-161))|(1<<(SqlBaseParserSUBSTRING-161))|(1<<(SqlBaseParserSYSTEM-161))|(1<<(SqlBaseParserTABLES-161))|(1<<(SqlBaseParserTABLESAMPLE-161))|(1<<(SqlBaseParserTEXT-161))|(1<<(SqlBaseParserTIES-161))|(1<<(SqlBaseParserTIME-161))|(1<<(SqlBaseParserTIMESTAMP-161))|(1<<(SqlBaseParserTO-161))|(1<<(SqlBaseParserTRANSACTION-161))|(1<<(SqlBaseParserTRUE-161))|(1<<(SqlBaseParserTRY_CAST-161))|(1<<(SqlBaseParserTYPE-161))|(1<<(SqlBaseParserUNBOUNDED-161)))) != 0) || (((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(SqlBaseParserUNCOMMITTED-193))|(1<<(SqlBaseParserUSE-193))|(1<<(SqlBaseParserUSER-193))|(1<<(SqlBaseParserVALIDATE-193))|(1<<(SqlBaseParserVERBOSE-193))|(1<<(SqlBaseParserVIEW-193))|(1<<(SqlBaseParserWITHOUT-193))|(1<<(SqlBaseParserWORK-193))|(1<<(SqlBaseParserWRITE-193))|(1<<(SqlBaseParserYEAR-193))|(1<<(SqlBaseParserZONE-193))|(1<<(SqlBaseParserPLUS-193))|(1<<(SqlBaseParserMINUS-193))|(1<<(SqlBaseParserSTRING-193))|(1<<(SqlBaseParserUNICODE_STRING-193)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserPARAMETER-225)))) != 0) {
			{
				p.SetState(804)
				p.Expression()
			}
			p.SetState(809)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__2 {
				{
					p.SetState(805)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(806)
					p.Expression()
				}

				p.SetState(811)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(814)
			p.Match(SqlBaseParserT__6)
		}

	case 24:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(815)
			p.Identifier()
		}

	case 25:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(816)

			var _m = p.Match(SqlBaseParserCURRENT_DATE)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}

	case 26:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(817)

			var _m = p.Match(SqlBaseParserCURRENT_TIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(821)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(818)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(819)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(820)
				p.Match(SqlBaseParserT__1)
			}

		}

	case 27:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(823)

			var _m = p.Match(SqlBaseParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(824)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(825)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(826)
				p.Match(SqlBaseParserT__1)
			}

		}

	case 28:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(829)

			var _m = p.Match(SqlBaseParserLOCALTIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(833)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(830)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(831)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(832)
				p.Match(SqlBaseParserT__1)
			}

		}

	case 29:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(835)

			var _m = p.Match(SqlBaseParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(839)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(836)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(837)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(838)
				p.Match(SqlBaseParserT__1)
			}

		}

	case 30:
		localctx = NewCurrentUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(841)

			var _m = p.Match(SqlBaseParserCURRENT_USER)

			localctx.(*CurrentUserContext).name = _m
		}

	case 31:
		localctx = NewCurrentPathContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(842)

			var _m = p.Match(SqlBaseParserCURRENT_PATH)

			localctx.(*CurrentPathContext).name = _m
		}

	case 32:
		localctx = NewSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(843)
			p.Match(SqlBaseParserSUBSTRING)
		}
		{
			p.SetState(844)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(845)
			p.valueExpression(0)
		}
		{
			p.SetState(846)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(847)
			p.valueExpression(0)
		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFOR {
			{
				p.SetState(848)
				p.Match(SqlBaseParserFOR)
			}
			{
				p.SetState(849)
				p.valueExpression(0)
			}

		}
		{
			p.SetState(852)
			p.Match(SqlBaseParserT__1)
		}

	case 33:
		localctx = NewNormalizeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(854)
			p.Match(SqlBaseParserNORMALIZE)
		}
		{
			p.SetState(855)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(856)
			p.valueExpression(0)
		}
		p.SetState(859)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__2 {
			{
				p.SetState(857)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(858)
				p.NormalForm()
			}

		}
		{
			p.SetState(861)
			p.Match(SqlBaseParserT__1)
		}

	case 34:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(863)
			p.Match(SqlBaseParserEXTRACT)
		}
		{
			p.SetState(864)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(865)
			p.Identifier()
		}
		{
			p.SetState(866)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(867)
			p.valueExpression(0)
		}
		{
			p.SetState(868)
			p.Match(SqlBaseParserT__1)
		}

	case 35:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(870)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(871)
			p.Expression()
		}
		{
			p.SetState(872)
			p.Match(SqlBaseParserT__1)
		}

	case 36:
		localctx = NewGroupingOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(874)
			p.Match(SqlBaseParserGROUPING)
		}
		{
			p.SetState(875)
			p.Match(SqlBaseParserT__0)
		}
		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-8)&-(0x1f+1)) == 0 && ((1<<uint((_la-8)))&((1<<(SqlBaseParserADD-8))|(1<<(SqlBaseParserADMIN-8))|(1<<(SqlBaseParserALL-8))|(1<<(SqlBaseParserANALYZE-8))|(1<<(SqlBaseParserANY-8))|(1<<(SqlBaseParserARRAY-8))|(1<<(SqlBaseParserASC-8))|(1<<(SqlBaseParserAT-8))|(1<<(SqlBaseParserAUTHORIZATION-8))|(1<<(SqlBaseParserBERNOULLI-8))|(1<<(SqlBaseParserCALL-8))|(1<<(SqlBaseParserCASCADE-8))|(1<<(SqlBaseParserCATALOGS-8))|(1<<(SqlBaseParserCOLUMN-8))|(1<<(SqlBaseParserCOLUMNS-8))|(1<<(SqlBaseParserCOMMENT-8))|(1<<(SqlBaseParserCOMMIT-8))|(1<<(SqlBaseParserCOMMITTED-8))|(1<<(SqlBaseParserCURRENT-8)))) != 0) || (((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(SqlBaseParserDATA-44))|(1<<(SqlBaseParserDATE-44))|(1<<(SqlBaseParserDAY-44))|(1<<(SqlBaseParserDEFINER-44))|(1<<(SqlBaseParserDESC-44))|(1<<(SqlBaseParserDISTRIBUTED-44))|(1<<(SqlBaseParserDOUBLE-44))|(1<<(SqlBaseParserEXCLUDING-44))|(1<<(SqlBaseParserEXPLAIN-44))|(1<<(SqlBaseParserFETCH-44))|(1<<(SqlBaseParserFILTER-44))|(1<<(SqlBaseParserFIRST-44))|(1<<(SqlBaseParserFOLLOWING-44))|(1<<(SqlBaseParserFORMAT-44))|(1<<(SqlBaseParserFUNCTIONS-44))|(1<<(SqlBaseParserGRANT-44)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(SqlBaseParserGRANTED-76))|(1<<(SqlBaseParserGRANTS-76))|(1<<(SqlBaseParserGRAPHVIZ-76))|(1<<(SqlBaseParserGROUPS-76))|(1<<(SqlBaseParserHOUR-76))|(1<<(SqlBaseParserIF-76))|(1<<(SqlBaseParserIGNORE-76))|(1<<(SqlBaseParserINCLUDING-76))|(1<<(SqlBaseParserINPUT-76))|(1<<(SqlBaseParserINTERVAL-76))|(1<<(SqlBaseParserINVOKER-76))|(1<<(SqlBaseParserIO-76))|(1<<(SqlBaseParserISOLATION-76))|(1<<(SqlBaseParserJSON-76))|(1<<(SqlBaseParserLAST-76))|(1<<(SqlBaseParserLATERAL-76))|(1<<(SqlBaseParserLEVEL-76))|(1<<(SqlBaseParserLIMIT-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(SqlBaseParserLOGICAL-108))|(1<<(SqlBaseParserMAP-108))|(1<<(SqlBaseParserMATERIALIZED-108))|(1<<(SqlBaseParserMINUTE-108))|(1<<(SqlBaseParserMONTH-108))|(1<<(SqlBaseParserNEXT-108))|(1<<(SqlBaseParserNFC-108))|(1<<(SqlBaseParserNFD-108))|(1<<(SqlBaseParserNFKC-108))|(1<<(SqlBaseParserNFKD-108))|(1<<(SqlBaseParserNO-108))|(1<<(SqlBaseParserNONE-108))|(1<<(SqlBaseParserNULLIF-108))|(1<<(SqlBaseParserNULLS-108))|(1<<(SqlBaseParserOFFSET-108))|(1<<(SqlBaseParserONLY-108))|(1<<(SqlBaseParserOPTION-108))|(1<<(SqlBaseParserORDINALITY-108))|(1<<(SqlBaseParserOUTPUT-108))|(1<<(SqlBaseParserOVER-108))|(1<<(SqlBaseParserPARTITION-108))|(1<<(SqlBaseParserPARTITIONS-108))|(1<<(SqlBaseParserPATH-108))|(1<<(SqlBaseParserPOSITION-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(SqlBaseParserPRECEDING-140))|(1<<(SqlBaseParserPRECISION-140))|(1<<(SqlBaseParserPRIVILEGES-140))|(1<<(SqlBaseParserPROPERTIES-140))|(1<<(SqlBaseParserRANGE-140))|(1<<(SqlBaseParserREAD-140))|(1<<(SqlBaseParserREFRESH-140))|(1<<(SqlBaseParserRENAME-140))|(1<<(SqlBaseParserREPEATABLE-140))|(1<<(SqlBaseParserREPLACE-140))|(1<<(SqlBaseParserRESET-140))|(1<<(SqlBaseParserRESPECT-140))|(1<<(SqlBaseParserRESTRICT-140))|(1<<(SqlBaseParserREVOKE-140))|(1<<(SqlBaseParserROLE-140))|(1<<(SqlBaseParserROLES-140))|(1<<(SqlBaseParserROLLBACK-140))|(1<<(SqlBaseParserROW-140))|(1<<(SqlBaseParserROWS-140))|(1<<(SqlBaseParserSCHEMA-140))|(1<<(SqlBaseParserSCHEMAS-140))|(1<<(SqlBaseParserSECOND-140))|(1<<(SqlBaseParserSECURITY-140))|(1<<(SqlBaseParserSERIALIZABLE-140))|(1<<(SqlBaseParserSESSION-140))|(1<<(SqlBaseParserSET-140))|(1<<(SqlBaseParserSETS-140)))) != 0) || (((_la-172)&-(0x1f+1)) == 0 && ((1<<uint((_la-172)))&((1<<(SqlBaseParserSHOW-172))|(1<<(SqlBaseParserSOME-172))|(1<<(SqlBaseParserSTART-172))|(1<<(SqlBaseParserSTATS-172))|(1<<(SqlBaseParserSUBSTRING-172))|(1<<(SqlBaseParserSYSTEM-172))|(1<<(SqlBaseParserTABLES-172))|(1<<(SqlBaseParserTABLESAMPLE-172))|(1<<(SqlBaseParserTEXT-172))|(1<<(SqlBaseParserTIES-172))|(1<<(SqlBaseParserTIME-172))|(1<<(SqlBaseParserTIMESTAMP-172))|(1<<(SqlBaseParserTO-172))|(1<<(SqlBaseParserTRANSACTION-172))|(1<<(SqlBaseParserTRY_CAST-172))|(1<<(SqlBaseParserTYPE-172))|(1<<(SqlBaseParserUNBOUNDED-172))|(1<<(SqlBaseParserUNCOMMITTED-172))|(1<<(SqlBaseParserUSE-172))|(1<<(SqlBaseParserUSER-172))|(1<<(SqlBaseParserVALIDATE-172))|(1<<(SqlBaseParserVERBOSE-172))|(1<<(SqlBaseParserVIEW-172)))) != 0) || (((_la-206)&-(0x1f+1)) == 0 && ((1<<uint((_la-206)))&((1<<(SqlBaseParserWITHOUT-206))|(1<<(SqlBaseParserWORK-206))|(1<<(SqlBaseParserWRITE-206))|(1<<(SqlBaseParserYEAR-206))|(1<<(SqlBaseParserZONE-206))|(1<<(SqlBaseParserIDENTIFIER-206))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-206))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-206))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-206)))) != 0) {
			{
				p.SetState(876)
				p.QualifiedName()
			}
			p.SetState(881)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__2 {
				{
					p.SetState(877)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(878)
					p.QualifiedName()
				}

				p.SetState(883)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(886)
			p.Match(SqlBaseParserT__1)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(897)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(889)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(890)
					p.Match(SqlBaseParserT__5)
				}
				{
					p.SetState(891)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(892)
					p.Match(SqlBaseParserT__6)
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(894)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(895)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(896)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			}

		}
		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())
	}

	return localctx
}

// IGstringContext is an interface to support dynamic dispatch.
type IGstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGstringContext differentiates from other interfaces.
	IsGstringContext()
}

type GstringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringContext() *GstringContext {
	var p = new(GstringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_gstring
	return p
}

func (*GstringContext) IsGstringContext() {}

func NewGstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringContext {
	var p = new(GstringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_gstring

	return p
}

func (s *GstringContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringContext) CopyFrom(ctx *GstringContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *GstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnicodeStringLiteralContext struct {
	*GstringContext
}

func NewUnicodeStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnicodeStringLiteralContext {
	var p = new(UnicodeStringLiteralContext)

	p.GstringContext = NewEmptyGstringContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GstringContext))

	return p
}

func (s *UnicodeStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnicodeStringLiteralContext) UNICODE_STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNICODE_STRING, 0)
}

func (s *UnicodeStringLiteralContext) UESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUESCAPE, 0)
}

func (s *UnicodeStringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *UnicodeStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUnicodeStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BasicStringLiteralContext struct {
	*GstringContext
}

func NewBasicStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BasicStringLiteralContext {
	var p = new(BasicStringLiteralContext)

	p.GstringContext = NewEmptyGstringContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GstringContext))

	return p
}

func (s *BasicStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicStringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *BasicStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBasicStringLiteral(s)
	}
}

func (s *BasicStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBasicStringLiteral(s)
	}
}

func (s *BasicStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBasicStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Gstring() (localctx IGstringContext) {
	localctx = NewGstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SqlBaseParserRULE_gstring)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(908)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSTRING:
		localctx = NewBasicStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(902)
			p.Match(SqlBaseParserSTRING)
		}

	case SqlBaseParserUNICODE_STRING:
		localctx = NewUnicodeStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(903)
			p.Match(SqlBaseParserUNICODE_STRING)
		}
		p.SetState(906)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(904)
				p.Match(SqlBaseParserUESCAPE)
			}
			{
				p.SetState(905)
				p.Match(SqlBaseParserSTRING)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier
	return p
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyFrom(ctx *TimeZoneSpecifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneIntervalContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneIntervalContext {
	var p = new(TimeZoneIntervalContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneIntervalContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *TimeZoneIntervalContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *TimeZoneIntervalContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *TimeZoneIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTimeZoneInterval(s)
	}
}

func (s *TimeZoneIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTimeZoneInterval(s)
	}
}

func (s *TimeZoneIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTimeZoneInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

type TimeZoneStringContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *TimeZoneStringContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *TimeZoneStringContext) Gstring() IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTimeZoneString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SqlBaseParserRULE_timeZoneSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTimeZoneIntervalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(910)
			p.Match(SqlBaseParserTIME)
		}
		{
			p.SetState(911)
			p.Match(SqlBaseParserZONE)
		}
		{
			p.SetState(912)
			p.Interval()
		}

	case 2:
		localctx = NewTimeZoneStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(913)
			p.Match(SqlBaseParserTIME)
		}
		{
			p.SetState(914)
			p.Match(SqlBaseParserZONE)
		}
		{
			p.SetState(915)
			p.Gstring()
		}

	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SqlBaseParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(918)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-211)&-(0x1f+1)) == 0 && ((1<<uint((_la-211)))&((1<<(SqlBaseParserEQ-211))|(1<<(SqlBaseParserNEQ-211))|(1<<(SqlBaseParserLT-211))|(1<<(SqlBaseParserLTE-211))|(1<<(SqlBaseParserGT-211))|(1<<(SqlBaseParserGTE-211)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonQuantifierContext is an interface to support dynamic dispatch.
type IComparisonQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonQuantifierContext differentiates from other interfaces.
	IsComparisonQuantifierContext()
}

type ComparisonQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonQuantifierContext() *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonQuantifier
	return p
}

func (*ComparisonQuantifierContext) IsComparisonQuantifierContext() {}

func NewComparisonQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_comparisonQuantifier

	return p
}

func (s *ComparisonQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *ComparisonQuantifierContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOME, 0)
}

func (s *ComparisonQuantifierContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY, 0)
}

func (s *ComparisonQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitComparisonQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ComparisonQuantifier() (localctx IComparisonQuantifierContext) {
	localctx = NewComparisonQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SqlBaseParserRULE_comparisonQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(920)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserALL || _la == SqlBaseParserANY || _la == SqlBaseParserSOME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SqlBaseParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(922)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserFALSE || _la == SqlBaseParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSign returns the sign token.
	GetSign() antlr.Token

	// SetSign sets the sign token.
	SetSign(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IIntervalFieldContext

	// GetTo returns the to rule contexts.
	GetTo() IIntervalFieldContext

	// SetFrom sets the from rule contexts.
	SetFrom(IIntervalFieldContext)

	// SetTo sets the to rule contexts.
	SetTo(IIntervalFieldContext)

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	sign   antlr.Token
	from   IIntervalFieldContext
	to     IIntervalFieldContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_interval
	return p
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetSign() antlr.Token { return s.sign }

func (s *IntervalContext) SetSign(v antlr.Token) { s.sign = v }

func (s *IntervalContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *IntervalContext) GetTo() IIntervalFieldContext { return s.to }

func (s *IntervalContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *IntervalContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *IntervalContext) Gstring() IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *IntervalContext) AllIntervalField() []IIntervalFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem())
	var tst = make([]IIntervalFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntervalFieldContext)
		}
	}

	return tst
}

func (s *IntervalContext) IntervalField(i int) IIntervalFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *IntervalContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *IntervalContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *IntervalContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SqlBaseParserRULE_interval)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(924)
		p.Match(SqlBaseParserINTERVAL)
	}
	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS {
		{
			p.SetState(925)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IntervalContext).sign = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IntervalContext).sign = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(928)
		p.Gstring()
	}
	{
		p.SetState(929)

		var _x = p.IntervalField()

		localctx.(*IntervalContext).from = _x
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(930)
			p.Match(SqlBaseParserTO)
		}
		{
			p.SetState(931)

			var _x = p.IntervalField()

			localctx.(*IntervalContext).to = _x
		}

	}

	return localctx
}

// IIntervalFieldContext is an interface to support dynamic dispatch.
type IIntervalFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalFieldContext differentiates from other interfaces.
	IsIntervalFieldContext()
}

type IntervalFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalFieldContext() *IntervalFieldContext {
	var p = new(IntervalFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_intervalField
	return p
}

func (*IntervalFieldContext) IsIntervalFieldContext() {}

func NewIntervalFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalFieldContext {
	var p = new(IntervalFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_intervalField

	return p
}

func (s *IntervalFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalFieldContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *IntervalFieldContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *IntervalFieldContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *IntervalFieldContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *IntervalFieldContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *IntervalFieldContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *IntervalFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntervalField(s)
	}
}

func (s *IntervalFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntervalField(s)
	}
}

func (s *IntervalFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitIntervalField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) IntervalField() (localctx IIntervalFieldContext) {
	localctx = NewIntervalFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SqlBaseParserRULE_intervalField)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDAY || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(SqlBaseParserHOUR-83))|(1<<(SqlBaseParserMINUTE-83))|(1<<(SqlBaseParserMONTH-83)))) != 0) || _la == SqlBaseParserSECOND || _la == SqlBaseParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INormalFormContext is an interface to support dynamic dispatch.
type INormalFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalFormContext differentiates from other interfaces.
	IsNormalFormContext()
}

type NormalFormContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalFormContext() *NormalFormContext {
	var p = new(NormalFormContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_normalForm
	return p
}

func (*NormalFormContext) IsNormalFormContext() {}

func NewNormalFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalFormContext {
	var p = new(NormalFormContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_normalForm

	return p
}

func (s *NormalFormContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalFormContext) NFD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFD, 0)
}

func (s *NormalFormContext) NFC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFC, 0)
}

func (s *NormalFormContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKD, 0)
}

func (s *NormalFormContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKC, 0)
}

func (s *NormalFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNormalForm(s)
	}
}

func (s *NormalFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNormalForm(s)
	}
}

func (s *NormalFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNormalForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) NormalForm() (localctx INormalFormContext) {
	localctx = NewNormalFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SqlBaseParserRULE_normalForm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(936)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(SqlBaseParserNFC-115))|(1<<(SqlBaseParserNFD-115))|(1<<(SqlBaseParserNFKC-115))|(1<<(SqlBaseParserNFKD-115)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGtypeContext is an interface to support dynamic dispatch.
type IGtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGtypeContext differentiates from other interfaces.
	IsGtypeContext()
}

type GtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGtypeContext() *GtypeContext {
	var p = new(GtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_gtype
	return p
}

func (*GtypeContext) IsGtypeContext() {}

func NewGtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GtypeContext {
	var p = new(GtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_gtype

	return p
}

func (s *GtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *GtypeContext) CopyFrom(ctx *GtypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *GtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RowTypeContext struct {
	*GtypeContext
}

func NewRowTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowTypeContext {
	var p = new(RowTypeContext)

	p.GtypeContext = NewEmptyGtypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GtypeContext))

	return p
}

func (s *RowTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowTypeContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *RowTypeContext) AllRowField() []IRowFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRowFieldContext)(nil)).Elem())
	var tst = make([]IRowFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRowFieldContext)
		}
	}

	return tst
}

func (s *RowTypeContext) RowField(i int) IRowFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRowFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRowFieldContext)
}

func (s *RowTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRowType(s)
	}
}

func (s *RowTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRowType(s)
	}
}

func (s *RowTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRowType(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalTypeContext struct {
	*GtypeContext
	from IIntervalFieldContext
	to   IIntervalFieldContext
}

func NewIntervalTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalTypeContext {
	var p = new(IntervalTypeContext)

	p.GtypeContext = NewEmptyGtypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GtypeContext))

	return p
}

func (s *IntervalTypeContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *IntervalTypeContext) GetTo() IIntervalFieldContext { return s.to }

func (s *IntervalTypeContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *IntervalTypeContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *IntervalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *IntervalTypeContext) AllIntervalField() []IIntervalFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem())
	var tst = make([]IIntervalFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntervalFieldContext)
		}
	}

	return tst
}

func (s *IntervalTypeContext) IntervalField(i int) IIntervalFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *IntervalTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *IntervalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntervalType(s)
	}
}

func (s *IntervalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntervalType(s)
	}
}

func (s *IntervalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitIntervalType(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayTypeContext struct {
	*GtypeContext
}

func NewArrayTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	p.GtypeContext = NewEmptyGtypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GtypeContext))

	return p
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) Gtype() IGtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGtypeContext)
}

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *ArrayTypeContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoublePrecisionTypeContext struct {
	*GtypeContext
}

func NewDoublePrecisionTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoublePrecisionTypeContext {
	var p = new(DoublePrecisionTypeContext)

	p.GtypeContext = NewEmptyGtypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GtypeContext))

	return p
}

func (s *DoublePrecisionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoublePrecisionTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE, 0)
}

func (s *DoublePrecisionTypeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECISION, 0)
}

func (s *DoublePrecisionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDoublePrecisionType(s)
	}
}

func (s *DoublePrecisionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDoublePrecisionType(s)
	}
}

func (s *DoublePrecisionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDoublePrecisionType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LegacyArrayTypeContext struct {
	*GtypeContext
}

func NewLegacyArrayTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LegacyArrayTypeContext {
	var p = new(LegacyArrayTypeContext)

	p.GtypeContext = NewEmptyGtypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GtypeContext))

	return p
}

func (s *LegacyArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LegacyArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *LegacyArrayTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *LegacyArrayTypeContext) Gtype() IGtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGtypeContext)
}

func (s *LegacyArrayTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *LegacyArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLegacyArrayType(s)
	}
}

func (s *LegacyArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLegacyArrayType(s)
	}
}

func (s *LegacyArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLegacyArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

type GenericTypeContext struct {
	*GtypeContext
}

func NewGenericTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GenericTypeContext {
	var p = new(GenericTypeContext)

	p.GtypeContext = NewEmptyGtypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GtypeContext))

	return p
}

func (s *GenericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GenericTypeContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *GenericTypeContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *GenericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGenericType(s)
	}
}

func (s *GenericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGenericType(s)
	}
}

func (s *GenericTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitGenericType(s)

	default:
		return t.VisitChildren(s)
	}
}

type DateTimeTypeContext struct {
	*GtypeContext
	base      antlr.Token
	precision ITypeParameterContext
}

func NewDateTimeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateTimeTypeContext {
	var p = new(DateTimeTypeContext)

	p.GtypeContext = NewEmptyGtypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GtypeContext))

	return p
}

func (s *DateTimeTypeContext) GetBase() antlr.Token { return s.base }

func (s *DateTimeTypeContext) SetBase(v antlr.Token) { s.base = v }

func (s *DateTimeTypeContext) GetPrecision() ITypeParameterContext { return s.precision }

func (s *DateTimeTypeContext) SetPrecision(v ITypeParameterContext) { s.precision = v }

func (s *DateTimeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *DateTimeTypeContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITHOUT, 0)
}

func (s *DateTimeTypeContext) AllTIME() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserTIME)
}

func (s *DateTimeTypeContext) TIME(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, i)
}

func (s *DateTimeTypeContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *DateTimeTypeContext) TypeParameter() ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *DateTimeTypeContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *DateTimeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDateTimeType(s)
	}
}

func (s *DateTimeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDateTimeType(s)
	}
}

func (s *DateTimeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDateTimeType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LegacyMapTypeContext struct {
	*GtypeContext
	keyType   IGtypeContext
	valueType IGtypeContext
}

func NewLegacyMapTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LegacyMapTypeContext {
	var p = new(LegacyMapTypeContext)

	p.GtypeContext = NewEmptyGtypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GtypeContext))

	return p
}

func (s *LegacyMapTypeContext) GetKeyType() IGtypeContext { return s.keyType }

func (s *LegacyMapTypeContext) GetValueType() IGtypeContext { return s.valueType }

func (s *LegacyMapTypeContext) SetKeyType(v IGtypeContext) { s.keyType = v }

func (s *LegacyMapTypeContext) SetValueType(v IGtypeContext) { s.valueType = v }

func (s *LegacyMapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LegacyMapTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *LegacyMapTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *LegacyMapTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *LegacyMapTypeContext) AllGtype() []IGtypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGtypeContext)(nil)).Elem())
	var tst = make([]IGtypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGtypeContext)
		}
	}

	return tst
}

func (s *LegacyMapTypeContext) Gtype(i int) IGtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGtypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGtypeContext)
}

func (s *LegacyMapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLegacyMapType(s)
	}
}

func (s *LegacyMapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLegacyMapType(s)
	}
}

func (s *LegacyMapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLegacyMapType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Gtype() (localctx IGtypeContext) {
	return p.gtype(0)
}

func (p *SqlBaseParser) gtype(_p int) (localctx IGtypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewGtypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IGtypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 74
	p.EnterRecursionRule(localctx, 74, SqlBaseParserRULE_gtype, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1029)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRowTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(939)
			p.Match(SqlBaseParserROW)
		}
		{
			p.SetState(940)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(941)
			p.RowField()
		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__2 {
			{
				p.SetState(942)
				p.Match(SqlBaseParserT__2)
			}
			{
				p.SetState(943)
				p.RowField()
			}

			p.SetState(948)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(949)
			p.Match(SqlBaseParserT__1)
		}

	case 2:
		localctx = NewIntervalTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(951)
			p.Match(SqlBaseParserINTERVAL)
		}
		{
			p.SetState(952)

			var _x = p.IntervalField()

			localctx.(*IntervalTypeContext).from = _x
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(953)
				p.Match(SqlBaseParserTO)
			}
			{
				p.SetState(954)

				var _x = p.IntervalField()

				localctx.(*IntervalTypeContext).to = _x
			}

		}

	case 3:
		localctx = NewDateTimeTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(957)

			var _m = p.Match(SqlBaseParserTIMESTAMP)

			localctx.(*DateTimeTypeContext).base = _m
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(958)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(959)

				var _x = p.TypeParameter()

				localctx.(*DateTimeTypeContext).precision = _x
			}
			{
				p.SetState(960)
				p.Match(SqlBaseParserT__1)
			}

		}
		p.SetState(967)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(964)
				p.Match(SqlBaseParserWITHOUT)
			}
			{
				p.SetState(965)
				p.Match(SqlBaseParserTIME)
			}
			{
				p.SetState(966)
				p.Match(SqlBaseParserZONE)
			}

		}

	case 4:
		localctx = NewDateTimeTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(969)

			var _m = p.Match(SqlBaseParserTIMESTAMP)

			localctx.(*DateTimeTypeContext).base = _m
		}
		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__0 {
			{
				p.SetState(970)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(971)

				var _x = p.TypeParameter()

				localctx.(*DateTimeTypeContext).precision = _x
			}
			{
				p.SetState(972)
				p.Match(SqlBaseParserT__1)
			}

		}
		{
			p.SetState(976)
			p.Match(SqlBaseParserWITH)
		}
		{
			p.SetState(977)
			p.Match(SqlBaseParserTIME)
		}
		{
			p.SetState(978)
			p.Match(SqlBaseParserZONE)
		}

	case 5:
		localctx = NewDateTimeTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(979)

			var _m = p.Match(SqlBaseParserTIME)

			localctx.(*DateTimeTypeContext).base = _m
		}
		p.SetState(984)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(980)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(981)

				var _x = p.TypeParameter()

				localctx.(*DateTimeTypeContext).precision = _x
			}
			{
				p.SetState(982)
				p.Match(SqlBaseParserT__1)
			}

		}
		p.SetState(989)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(986)
				p.Match(SqlBaseParserWITHOUT)
			}
			{
				p.SetState(987)
				p.Match(SqlBaseParserTIME)
			}
			{
				p.SetState(988)
				p.Match(SqlBaseParserZONE)
			}

		}

	case 6:
		localctx = NewDateTimeTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(991)

			var _m = p.Match(SqlBaseParserTIME)

			localctx.(*DateTimeTypeContext).base = _m
		}
		p.SetState(996)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__0 {
			{
				p.SetState(992)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(993)

				var _x = p.TypeParameter()

				localctx.(*DateTimeTypeContext).precision = _x
			}
			{
				p.SetState(994)
				p.Match(SqlBaseParserT__1)
			}

		}
		{
			p.SetState(998)
			p.Match(SqlBaseParserWITH)
		}
		{
			p.SetState(999)
			p.Match(SqlBaseParserTIME)
		}
		{
			p.SetState(1000)
			p.Match(SqlBaseParserZONE)
		}

	case 7:
		localctx = NewDoublePrecisionTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1001)
			p.Match(SqlBaseParserDOUBLE)
		}
		{
			p.SetState(1002)
			p.Match(SqlBaseParserPRECISION)
		}

	case 8:
		localctx = NewLegacyArrayTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1003)
			p.Match(SqlBaseParserARRAY)
		}
		{
			p.SetState(1004)
			p.Match(SqlBaseParserLT)
		}
		{
			p.SetState(1005)
			p.gtype(0)
		}
		{
			p.SetState(1006)
			p.Match(SqlBaseParserGT)
		}

	case 9:
		localctx = NewLegacyMapTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1008)
			p.Match(SqlBaseParserMAP)
		}
		{
			p.SetState(1009)
			p.Match(SqlBaseParserLT)
		}
		{
			p.SetState(1010)

			var _x = p.gtype(0)

			localctx.(*LegacyMapTypeContext).keyType = _x
		}
		{
			p.SetState(1011)
			p.Match(SqlBaseParserT__2)
		}
		{
			p.SetState(1012)

			var _x = p.gtype(0)

			localctx.(*LegacyMapTypeContext).valueType = _x
		}
		{
			p.SetState(1013)
			p.Match(SqlBaseParserGT)
		}

	case 10:
		localctx = NewGenericTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1015)
			p.Identifier()
		}
		p.SetState(1027)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1016)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(1017)
				p.TypeParameter()
			}
			p.SetState(1022)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__2 {
				{
					p.SetState(1018)
					p.Match(SqlBaseParserT__2)
				}
				{
					p.SetState(1019)
					p.TypeParameter()
				}

				p.SetState(1024)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1025)
				p.Match(SqlBaseParserT__1)
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewArrayTypeContext(p, NewGtypeContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_gtype)
			p.SetState(1031)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1032)
				p.Match(SqlBaseParserARRAY)
			}
			p.SetState(1036)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1033)
					p.Match(SqlBaseParserT__5)
				}
				{
					p.SetState(1034)
					p.Match(SqlBaseParserINTEGER_VALUE)
				}
				{
					p.SetState(1035)
					p.Match(SqlBaseParserT__6)
				}

			}

		}
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}

	return localctx
}

// IRowFieldContext is an interface to support dynamic dispatch.
type IRowFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRowFieldContext differentiates from other interfaces.
	IsRowFieldContext()
}

type RowFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowFieldContext() *RowFieldContext {
	var p = new(RowFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_rowField
	return p
}

func (*RowFieldContext) IsRowFieldContext() {}

func NewRowFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowFieldContext {
	var p = new(RowFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_rowField

	return p
}

func (s *RowFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *RowFieldContext) Gtype() IGtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGtypeContext)
}

func (s *RowFieldContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RowFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRowField(s)
	}
}

func (s *RowFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRowField(s)
	}
}

func (s *RowFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRowField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) RowField() (localctx IRowFieldContext) {
	localctx = NewRowFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SqlBaseParserRULE_rowField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1047)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1043)
			p.gtype(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1044)
			p.Identifier()
		}
		{
			p.SetState(1045)
			p.gtype(0)
		}

	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) Gtype() IGtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGtypeContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SqlBaseParserRULE_typeParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1051)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1049)
			p.Match(SqlBaseParserINTEGER_VALUE)
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserAUTHORIZATION, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserDOUBLE, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserGROUPS, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRECISION, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWITHOUT, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1050)
			p.gtype(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whenClause
	return p
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (s *WhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SqlBaseParserRULE_whenClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.Match(SqlBaseParserWHEN)
	}
	{
		p.SetState(1054)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1055)
		p.Match(SqlBaseParserTHEN)
	}
	{
		p.SetState(1056)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

	return localctx
}

// IFilterContext is an interface to support dynamic dispatch.
type IFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterContext differentiates from other interfaces.
	IsFilterContext()
}

type FilterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterContext() *FilterContext {
	var p = new(FilterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_filter
	return p
}

func (*FilterContext) IsFilterContext() {}

func NewFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterContext {
	var p = new(FilterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_filter

	return p
}

func (s *FilterContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *FilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *FilterContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *FilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFilter(s)
	}
}

func (s *FilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFilter(s)
	}
}

func (s *FilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Filter() (localctx IFilterContext) {
	localctx = NewFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SqlBaseParserRULE_filter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1058)
		p.Match(SqlBaseParserFILTER)
	}
	{
		p.SetState(1059)
		p.Match(SqlBaseParserT__0)
	}
	{
		p.SetState(1060)
		p.Match(SqlBaseParserWHERE)
	}
	{
		p.SetState(1061)
		p.booleanExpression(0)
	}
	{
		p.SetState(1062)
		p.Match(SqlBaseParserT__1)
	}

	return localctx
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedName
	return p
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SqlBaseParserRULE_qualifiedName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1064)
		p.Identifier()
	}
	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1065)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1066)
				p.Identifier()
			}

		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyFrom(ctx *IdentifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	*IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBackQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuotedIdentifierContext struct {
	*IdentifierContext
}

func NewQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type DigitIdentifierContext struct {
	*IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDigitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnquotedIdentifierContext struct {
	*IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonReservedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUnquotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SqlBaseParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1077)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1072)
			p.Match(SqlBaseParserIDENTIFIER)
		}

	case SqlBaseParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1073)
			p.Match(SqlBaseParserQUOTED_IDENTIFIER)
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserAUTHORIZATION, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserDOUBLE, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserGROUPS, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRECISION, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWITHOUT, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1074)
			p.NonReserved()
		}

	case SqlBaseParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1075)
			p.Match(SqlBaseParserBACKQUOTED_IDENTIFIER)
		}

	case SqlBaseParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1076)
			p.Match(SqlBaseParserDIGIT_IDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyFrom(ctx *NumberContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	*NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoubleLiteralContext struct {
	*NumberContext
}

func NewDoubleLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE_VALUE, 0)
}

func (s *DoubleLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDoubleLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerLiteralContext struct {
	*NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SqlBaseParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1080)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(1079)
				p.Match(SqlBaseParserMINUS)
			}

		}
		{
			p.SetState(1082)
			p.Match(SqlBaseParserDECIMAL_VALUE)
		}

	case 2:
		localctx = NewDoubleLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1084)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(1083)
				p.Match(SqlBaseParserMINUS)
			}

		}
		{
			p.SetState(1086)
			p.Match(SqlBaseParserDOUBLE_VALUE)
		}

	case 3:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1088)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(1087)
				p.Match(SqlBaseParserMINUS)
			}

		}
		{
			p.SetState(1090)
			p.Match(SqlBaseParserINTEGER_VALUE)
		}

	}

	return localctx
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonReserved
	return p
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *NonReservedContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADMIN, 0)
}

func (s *NonReservedContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *NonReservedContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *NonReservedContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAT, 0)
}

func (s *NonReservedContext) AUTHORIZATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAUTHORIZATION, 0)
}

func (s *NonReservedContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBERNOULLI, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALL, 0)
}

func (s *NonReservedContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASCADE, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOGS, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMITTED, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *NonReservedContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINER, 0)
}

func (s *NonReservedContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE, 0)
}

func (s *NonReservedContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCLUDING, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *NonReservedContext) FETCH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFETCH, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMAT, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, 0)
}

func (s *NonReservedContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTED, 0)
}

func (s *NonReservedContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTS, 0)
}

func (s *NonReservedContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRAPHVIZ, 0)
}

func (s *NonReservedContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPS, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *NonReservedContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *NonReservedContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCLUDING, 0)
}

func (s *NonReservedContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *NonReservedContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINVOKER, 0)
}

func (s *NonReservedContext) IO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIO, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserISOLATION, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJSON, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *NonReservedContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEVEL, 0)
}

func (s *NonReservedContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOGICAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *NonReservedContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEXT, 0)
}

func (s *NonReservedContext) NFC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFC, 0)
}

func (s *NonReservedContext) NFD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFD, 0)
}

func (s *NonReservedContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKC, 0)
}

func (s *NonReservedContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKD, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNO, 0)
}

func (s *NonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNONE, 0)
}

func (s *NonReservedContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLIF, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserONLY, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *NonReservedContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDINALITY, 0)
}

func (s *NonReservedContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTPUT, 0)
}

func (s *NonReservedContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVER, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONS, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPATH, 0)
}

func (s *NonReservedContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPOSITION, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *NonReservedContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECISION, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *NonReservedContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRANGE, 0)
}

func (s *NonReservedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFRESH, 0)
}

func (s *NonReservedContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *NonReservedContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESPECT, 0)
}

func (s *NonReservedContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESTRICT, 0)
}

func (s *NonReservedContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *NonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *NonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLES, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLBACK, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *NonReservedContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *NonReservedContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMAS, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *NonReservedContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECURITY, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *NonReservedContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOME, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTART, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATS, 0)
}

func (s *NonReservedContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTRING, 0)
}

func (s *NonReservedContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *NonReservedContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLESAMPLE, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEXT, 0)
}

func (s *NonReservedContext) TIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIES, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRY_CAST, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSE, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSER, 0)
}

func (s *NonReservedContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALIDATE, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVERBOSE, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *NonReservedContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITHOUT, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWORK, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWRITE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SqlBaseParserRULE_nonReserved)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserAUTHORIZATION)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS)|(1<<SqlBaseParserCOMMENT)|(1<<SqlBaseParserCOMMIT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserDOUBLE-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXPLAIN-32)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SqlBaseParserFETCH-66))|(1<<(SqlBaseParserFILTER-66))|(1<<(SqlBaseParserFIRST-66))|(1<<(SqlBaseParserFOLLOWING-66))|(1<<(SqlBaseParserFORMAT-66))|(1<<(SqlBaseParserFUNCTIONS-66))|(1<<(SqlBaseParserGRANT-66))|(1<<(SqlBaseParserGRANTED-66))|(1<<(SqlBaseParserGRANTS-66))|(1<<(SqlBaseParserGRAPHVIZ-66))|(1<<(SqlBaseParserGROUPS-66))|(1<<(SqlBaseParserHOUR-66))|(1<<(SqlBaseParserIF-66))|(1<<(SqlBaseParserIGNORE-66))|(1<<(SqlBaseParserINCLUDING-66))|(1<<(SqlBaseParserINPUT-66))|(1<<(SqlBaseParserINTERVAL-66))|(1<<(SqlBaseParserINVOKER-66))|(1<<(SqlBaseParserIO-66))|(1<<(SqlBaseParserISOLATION-66)))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(SqlBaseParserJSON-99))|(1<<(SqlBaseParserLAST-99))|(1<<(SqlBaseParserLATERAL-99))|(1<<(SqlBaseParserLEVEL-99))|(1<<(SqlBaseParserLIMIT-99))|(1<<(SqlBaseParserLOGICAL-99))|(1<<(SqlBaseParserMAP-99))|(1<<(SqlBaseParserMATERIALIZED-99))|(1<<(SqlBaseParserMINUTE-99))|(1<<(SqlBaseParserMONTH-99))|(1<<(SqlBaseParserNEXT-99))|(1<<(SqlBaseParserNFC-99))|(1<<(SqlBaseParserNFD-99))|(1<<(SqlBaseParserNFKC-99))|(1<<(SqlBaseParserNFKD-99))|(1<<(SqlBaseParserNO-99))|(1<<(SqlBaseParserNONE-99))|(1<<(SqlBaseParserNULLIF-99))|(1<<(SqlBaseParserNULLS-99))|(1<<(SqlBaseParserOFFSET-99))|(1<<(SqlBaseParserONLY-99))|(1<<(SqlBaseParserOPTION-99)))) != 0) || (((_la-132)&-(0x1f+1)) == 0 && ((1<<uint((_la-132)))&((1<<(SqlBaseParserORDINALITY-132))|(1<<(SqlBaseParserOUTPUT-132))|(1<<(SqlBaseParserOVER-132))|(1<<(SqlBaseParserPARTITION-132))|(1<<(SqlBaseParserPARTITIONS-132))|(1<<(SqlBaseParserPATH-132))|(1<<(SqlBaseParserPOSITION-132))|(1<<(SqlBaseParserPRECEDING-132))|(1<<(SqlBaseParserPRECISION-132))|(1<<(SqlBaseParserPRIVILEGES-132))|(1<<(SqlBaseParserPROPERTIES-132))|(1<<(SqlBaseParserRANGE-132))|(1<<(SqlBaseParserREAD-132))|(1<<(SqlBaseParserREFRESH-132))|(1<<(SqlBaseParserRENAME-132))|(1<<(SqlBaseParserREPEATABLE-132))|(1<<(SqlBaseParserREPLACE-132))|(1<<(SqlBaseParserRESET-132))|(1<<(SqlBaseParserRESPECT-132))|(1<<(SqlBaseParserRESTRICT-132))|(1<<(SqlBaseParserREVOKE-132))|(1<<(SqlBaseParserROLE-132))|(1<<(SqlBaseParserROLES-132))|(1<<(SqlBaseParserROLLBACK-132))|(1<<(SqlBaseParserROW-132))|(1<<(SqlBaseParserROWS-132))|(1<<(SqlBaseParserSCHEMA-132)))) != 0) || (((_la-164)&-(0x1f+1)) == 0 && ((1<<uint((_la-164)))&((1<<(SqlBaseParserSCHEMAS-164))|(1<<(SqlBaseParserSECOND-164))|(1<<(SqlBaseParserSECURITY-164))|(1<<(SqlBaseParserSERIALIZABLE-164))|(1<<(SqlBaseParserSESSION-164))|(1<<(SqlBaseParserSET-164))|(1<<(SqlBaseParserSETS-164))|(1<<(SqlBaseParserSHOW-164))|(1<<(SqlBaseParserSOME-164))|(1<<(SqlBaseParserSTART-164))|(1<<(SqlBaseParserSTATS-164))|(1<<(SqlBaseParserSUBSTRING-164))|(1<<(SqlBaseParserSYSTEM-164))|(1<<(SqlBaseParserTABLES-164))|(1<<(SqlBaseParserTABLESAMPLE-164))|(1<<(SqlBaseParserTEXT-164))|(1<<(SqlBaseParserTIES-164))|(1<<(SqlBaseParserTIME-164))|(1<<(SqlBaseParserTIMESTAMP-164))|(1<<(SqlBaseParserTO-164))|(1<<(SqlBaseParserTRANSACTION-164))|(1<<(SqlBaseParserTRY_CAST-164))|(1<<(SqlBaseParserTYPE-164))|(1<<(SqlBaseParserUNBOUNDED-164))|(1<<(SqlBaseParserUNCOMMITTED-164)))) != 0) || (((_la-196)&-(0x1f+1)) == 0 && ((1<<uint((_la-196)))&((1<<(SqlBaseParserUSE-196))|(1<<(SqlBaseParserUSER-196))|(1<<(SqlBaseParserVALIDATE-196))|(1<<(SqlBaseParserVERBOSE-196))|(1<<(SqlBaseParserVIEW-196))|(1<<(SqlBaseParserWITHOUT-196))|(1<<(SqlBaseParserWORK-196))|(1<<(SqlBaseParserWRITE-196))|(1<<(SqlBaseParserYEAR-196))|(1<<(SqlBaseParserZONE-196)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *SqlBaseParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 6:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 16:
		var t *RelationContext = nil
		if localctx != nil {
			t = localctx.(*RelationContext)
		}
		return p.Relation_Sempred(t, predIndex)

	case 25:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 27:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 28:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 37:
		var t *GtypeContext = nil
		if localctx != nil {
			t = localctx.(*GtypeContext)
		}
		return p.Gtype_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SqlBaseParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) Relation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 13)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) Gtype_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
